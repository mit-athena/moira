\documentstyle[fullpage]{article}
\begin{document}

\begin{center}
{\Large Moira Queries}
\end{center}

The following descriptions contain the long name of the query, the
short name, any arguments in parenthesis, then a ``$\rightarrow$''
followed by any return values. Zero or more sets of values may be
returned. The three values ``modtime, modby, modwith'' return the date
and time of the last modification, the name of the kerberos principal
who made the modification, and the name of the program that performed
the query.

If a description says nothing about access control, then it may only
be executed by people on the ACL for that query.  Most query ACLs
contain a small number of people, the ``gods'' for that query.  There is
also a magic list called ``default'' (the fact that it contains the user
named ``default'' is actually the magic) which is treated as if it
contained the name of every user.  This list is used as the query ACL
for some public queries.

Any query may return: MR\_PERM ``Insufficient permission to perform
requested database access'' or MR\_ARGS ``Incorrect number of
arguments''.  Any retrieval query may return MR\_NO\_MATCH ``No records
in database match query''.  Any add or update query may return
MR\_BAD\_CHAR ``Illegal character in argument'' if a bad character is in
an argument that has character restrictions, or MR\_EXISTS if the new
object to be added or new name of existing object conflicts with
another object already in the database.  Other errors are listed with
each query.


\section{Users, Finger, and Post Office Boxes}

\begin{description}
\item[get\_all\_logins, galo]() $\rightarrow$ login, uid, shell, last, first, mi

Returns info on every account in the database.  The returned info is a
summary of the account info, not the complete information.

\item[get\_all\_active\_logins, gaal]() $\rightarrow$ login, uid, shell, last, first, mi

Returns info on every account for which the status field is non-zero.
The returned info is a summary of the account info, not the complete
information.

\item[get\_user\_account\_by\_login, gual](login) $\rightarrow$ login, uid,
shell, last, first, mi, state, mitid, class, comments, signature,
secure, modtime, modby, modwith

Returns complete account information on the named account.  Wildcards
may be used in the {\em login} name specified.  If the person executing
the query is not on the query ACL, then the query only succeeds if the
only retrieved information is about the user making the request.

\item[get\_user\_account\_by\_uid, guau](uid) $\rightarrow$ login, uid, shell,
last, first, mi, state, mitid, class, comments, signature, secure,
modtime, modby, modwith

Returns complete account information on any account with the specified
{\em uid}.  If the person executing the query is not on the query ACL,
then the query only succeeds if the only retrieved information is
about the user making the request.

\item[get\_user\_account\_by\_name, guan](first, last) $\rightarrow$ login, uid, shell,
last, first, mi, state, mitid, class, comments, signature, secure, modtime,
modby, modwith

Returns complete account information on any account with matching
{\em first} and {\em last} name fields.  Either or both names may contain
wildcards, so that this query can do the equivalent of lookup by
firstname or lookup by lastname.

\item[get\_user\_account\_by\_class, guac](class) $\rightarrow$ login, uid, shell, last,
first, mi, state, mitid, class, comments, signature, secure, modtime,
modby, modwith

Returns complete account information on any account with a matching
class field.  The given class may contain wildcards.

\item[get\_user\_account\_by\_id, guai](id) $\rightarrow$ login, uid, shell, last, first,
mi, state, mitid, class, comments, signature, secure, modtime, modby, modwith

Returns complete account information on any account with a matching
MIT ID field.  The given id may contain wildcards.

\item[get\_user\_by\_login, gubl](login) $\rightarrow$login, uid, shell,
last, first, mi, state, mitid, class, modtime, modby, modwith

{\bf Obsolete.}  Returns complete account information on the named
account.  Wildcards may be used in the {\em login} name specified.  If
the person executing the query is not on the query ACL, then the query
only succeeds if the only retrieved information is about the user
making the request.

\item[get\_user\_by\_uid, gubu](uid) $\rightarrow$ login, uid, shell, last, first, mi,
state, mitid, class, modtime, modby, modwith

{\bf Obsolete.}  Returns complete account information on any account
with the specified {\em uid}.  If the person executing the query is not
on the query ACL, then the query only succeeds if the only retrieved
information is about the user making the request.

\item[get\_user\_by\_name, gubn](first, last) $\rightarrow$ login, uid, shell,
last, first, mi, state, mitid, class, modtime, modby, modwith

{\bf Obsolete.}  Returns complete account information on any account
with matching {\em first} and {\em last} name fields.  Either or both
names may contain wildcards, so that this query can do the equivalent
of lookup by firstname or lookup by lastname.

\item[get\_user\_by\_class, gubc](class) $\rightarrow$ login, uid, shell, last,
first, mi, state, mitid, class, modtime, modby, modwith

{\bf Obsolete.}  Returns complete account information on any account
with a matching class field.  The given class may contain wildcards.

\item[get\_user\_by\_mitid, gubm](crypt(id)) $\rightarrow$ login, uid, shell, last, first,
mi, state, mitid, class, modtime, modby, modwith

{\bf Obsolete.}  Returns complete account information on any account
with a matching MIT ID field.  The given id may contain wildcards.

\item[add\_user\_account, auac](login, uid, shell, last, first, mi, state, mitid,
class, comments, signature, secure)

Adds a new user to the database. {\em login} must not match any
existing {\em login}s. {\em uid} and {\em state} must be integers. If
the given uid is {\bf UNIQUE\_UID} as defined in {\em
$\langle$moira.h$\rangle$}, the next unused uid will be assigned. If
{\em login} is {\bf UNIQUE\_LOGIN} as defined in {\em
$\langle$moira.h$\rangle$}, the login name will be a ``\#'' followed by
the uid. For example, when adding a person so that they may register
later, the query ausr(UNIQUE\_LOGIN, UNIQUE\_UID, /bin/csh, {\em Last,
First, M}, 0, 999999999, {\em class}) is used. The {\em class}
field must contain a value specified as a {\bf TYPE} alias for {\bf
class}. The {\em comments} field can contain any string. The {\em
signature} is a binary record from the GDSS authenticating the mapping
from ID to login. This query also initializes the finger record for
this user with just their full name, and sets their pobox to {\bf
NONE}. It updates the modtime on the user, finger and pobox records.
Errors: MR\_NOT\_UNIQUE ``Arguments not unique'' if the login name is not
unique, or MR\_BAD\_CLASS ``Specified class is not known'' if the class is
not in the alias database.

\item[add\_user, ausr](login, uid, shell, last, first, mi, state, mitid,
class)

{\bf Obsolete.} Adds a new user to the database. {\em login} must not
match any existing {\em login}s. {\em uid} and {\em state} must be
integers. If the given uid is {\bf UNIQUE\_UID} as defined in {\em
$\langle$moira.h$\rangle$}, the next unused uid will be assigned. If
{\em login} is {\bf UNIQUE\_LOGIN} as defined in {\em
$\langle$moira.h$\rangle$}, the login name will be a ``\#'' followed by
the uid. For example, when adding a person so that they may register
later, the query ausr(UNIQUE\_LOGIN, UNIQUE\_UID, /bin/csh, {\em Last,
First, M}, 0, 999999999, {\em class}) is used. The {\em class} field
must contain a value specified as a {\bf TYPE} alias for {\bf class}.
This query also initializes the finger record for this user with just
their full name, and sets their pobox to {\bf NONE}. It updates the
modtime on the user, finger and pobox records. Errors: MR\_NOT\_UNIQUE
``Arguments not unique'' if the login name is not unique, or
MR\_BAD\_CLASS ``Specified class is not known'' if the class is not in the
alias database.

\item[register\_user, rusr](uid, login, fstype)

Registers a user. This consists of changing their username, and
creating a pobox, a group list, a filesystem, and a quota for them.
The user is identified by {\em uid}, which must match exactly one
existing user. Further, this user must currently have a {\em status}
of 0. The user will be left with a {\em status} of 2. The pobox
created will be of type {\bf POP} on the least loaded post office. The
group list will have the user as an owner, and a unique GID will be
assigned. The filesystem will be allocated on the least loaded
fileserver which supports {\em fstype}, where {\em fstype} is {\bf
MR\_FS\_STUDENT, MR\_FS\_FACULTY, MR\_FS\_STAFF}, or {\bf MR\_FS\_MISC} as
defined in {\em $\langle$moira.h$\rangle$}. A quota will be assigned
to the user on his filesystem with the value taken from {\bf
def\_quota} in the values table. Errors: MR\_NO\_MATCH, MR\_NOT\_UNIQUE
``Arguments not unique'' if the uid does not specify exactly one user;
MR\_IN\_USE ``Object is in use'' if the login name is already taken.

\item[update\_user\_account, uuac](login, newlogin, uid, shell, last,
first, mi, state, mitid, class, comments, signature, secure)

Updates the info in a user entry.  {\em login} specifies the existing
login name, the remaining arguments will replace the current values
of those fields.  This is not equivalent to deleting the user and
adding a new one, as all references to this user will still exist,
even if the login name is changed.  All fields must be specified, even
if the value is to remain unchanged.  {\em login} must match exactly one
user in the database.  {\em newlogin} must either match the existing
login or be unique in the database.  The {\em class} field must contain
a value specified as a {\bf TYPE} alias for {\bf class}.  {\em uid} and
{\em state} must be integers.  The modtime fields in the user's record
will be updated.  Errors: MR\_USER ``No such user'' if the login name
does not match exactly one user, MR\_NOT\_UNIQUE ``Arguments not unique''
if the new login name is not unique, or MR\_BAD\_CLASS ``Specified class
is not known'' if the class is not in the alias database.

\item[update\_user, uusr](login, newlogin, uid, shell, last, first, mi, state,
mitid, class)

{\bf Obsolete.}  Updates the info in a user entry.  {\em login} specifies
the existing login name, the remaining arguments will replace the
current values of those fields.  This is not equivalent to deleting
the user and adding a new one, as all references to this user will
still exist, even if the login name is changed.  All fields must be
specified, even if the value is to remain unchanged.  {\em login} must
match exactly one user in the database.  {\em newlogin} must either
match the existing login or be unique in the database.  The {\em class}
field must contain a value specified as a {\bf TYPE} alias for
{\bf class}.  {\em uid} and {\em state} must be integers.  The modtime
fields in the user's record will be updated.  Errors: MR\_USER ``No such
user'' if the login name does not match exactly one user, MR\_NOT\_UNIQUE
``Arguments not unique'' if the new login name is not unique, or
MR\_BAD\_CLASS ``Specified class is not known'' if the class is not in the
alias database.

\item[update\_user\_shell, uush](login, shell)

Updates a user's shell.  {\em login} must match exactly one user.  The
modtime fields in the user's record will be updated.  This query may
be executed by the target user or by someone on the query ACL.
Errors: MR\_USER ``No such user'' if the login name does not match
exactly one user.

\item[update\_user\_status, uust](login, status)

Updates a user's {\em status}.  {\em login} must match exactly one user.
The modtime fields in the user's record will be updated.  Errors:
MR\_USER ``No such user'' if the login name does not match exactly one
user.

\item[update\_user\_security\_status, uuss](login, status)

Updates a user's {\em secure}ity field.  {\em login} must match exactly
one user.  The modtime fields in the user's record will be updated.
Errors: MR\_USER ``No such user'' if the login name does not match
exactly one user.

\item[delete\_user, dusr](login)

Deletes a user record. {\em login} must match exactly one user. {\em
The user must have a status of zero, or MR\_IN\_USE will be returned.}
This will only be allowed if the user is not a member of any lists,
has any quotas assigned, or is the owner of an object. It will also
delete associated finger information, post office box, and any quotas
the user has. Errors: MR\_USER ``No such user'' if the login name does
not match exactly one user, MR\_IN\_USE ``Object is in use'' if the user
is a member of a list, has a quota or is an ACE.

\item[get\_kerberos\_user\_map, gkum](login, kerberos) $\rightarrow$ login,
kerberos

Gets kerberos principal to user mapping entries.  Both {\em login} and
{\em kerberos} may contain wildcards.  A user may only retrieve his own
entry unless he is on the query ACL.

\item[add\_kerberos\_user\_map, akum](login, kerberos)

Adds a new kerberos principal to user mapping entry.  {\em Login} must
match exactly one user.  {\em Kerberos} is a case-sensitive
name/instance/realm principal string.  These mappings must be strictly
one-to-one, so a new entry will not be allowed if the user or
principal already appears in the mapping table.  A user may only add a
mapping for himself unless he is on the query ACL.  Errors: MR\_USER
``No such user'' if {\em login} does not match exactly one user,
MR\_EXISTS ``Record already exists'' if the user or principal already
has a mapping.

\item[delete\_kerberos\_user\_map, dkum](login, kerberos)

Deletes a kerberos principal to user mapping.  {\em Login} must match
exactly one user.  {\em Kerberos} must exactly match an existing mapping
for that user.  A user may only remove his own mapping unless he is on
the query ACL.  Errors: MR\_USER ``No such user'' if {\em login} does not
match exactly one user.

\item[get\_finger\_by\_login, gfbl](login) $\rightarrow$ login, fullname, nicname,
home\_addr, home\_phone, office\_addr, office\_phone, department,
affiliation, modtime, modby, modwith

Gets all of the finger information for the specified user.  {\em login}
must match exactly one user.  The target user may retrieve his
information.  It is safe to point the query ACL at the list of all
users.  Errors: MR\_USER ``No such user'' if the login name does not
match exactly one user.

\item[update\_finger\_by\_login, ufbl](login, fullname, nicname, home\_addr,
home\_phone, office\_addr, office\_phone, department, affiliation)

Allows any part of the finger information to be changed for a
specified account.  {\em login} must match exactly one user.  The
remaining fields are free-form, and may contain anything.  The modtime
fields in the finger record will be updated.  A user may update his
own information.  Errors: MR\_USER ``No such user'' if the login name
does not match exactly one user.

\item[get\_pobox, gpob](login) $\rightarrow$ login, type, box, modtime,
modby, modwith

Retrieves a user's post office box assignment. The {\em login} name
must match exactly one user. See {\em set\_pobox} for a summary of the
returned fields. The owner of the pobox may perform this query.
Errors: MR\_USER ``No such user'' if the login name does not match
exactly one user.

\item[get\_all\_poboxes, gapo]() $\rightarrow$ login, type, box

Retrieves all of the post office boxes from the database.  See
{\em set\_pobox} for a summary of the returned fields.

\item[get\_poboxes\_pop, gpop]() $\rightarrow$ login, type, machine

Retrieves all of the post office boxes of type {\bf POP} from the
database.  See {\em set\_pobox} for a summary of the returned fields.

\item[get\_poboxes\_smtp, gpos]() $\rightarrow$ login, type, box

Retrieves all of the post office boxes of type {\bf SMTP} from the
database.  See {\em set\_pobox} for a summary of the returned fields.

\item[set\_pobox, spob](login, type, box)

Establishes a user's post office box.  The given {\em login} must match
exactly one user.  The {\em type} will be checked against the alias
database for valid {\bf pobox} types.  Currently allowed types are
{\bf POP}, {\bf SMTP}, and {\bf NONE}.  If the type is {\bf POP}, then box
must name a machine known by MR.  If the type is {\bf SMTP}, then box
is the user's mail address with no other interpretation by MR.  A
type of {\bf NONE} is the same as not having a pobox.  The modtime
fields on the pobox record will be set.  The owner of the target pobox
may perform this query.  Errors: MR\_USER ``No such user'' if the login
name does not match exactly one user, or MR\_TYPE ``Invalid type'' if
the type is not {\bf POP}, {\bf SMTP}, or {\bf NONE}.

\item[set\_pobox\_pop, spop](login)

Forces a user's pobox to be type {\bf POP}.  The {\em login} name must
match exactly one user.  If the user's pobox is already of type
{\bf POP}, nothing will be changed.  If the user has previously had a
pobox of type {\bf POP}, then the previous post office machine
assignment will be restored.  If there was no previous post office
assignment, the query will fail with MR\_MACHINE ``Unknown machine''
since it will be unable to choose a post office machine.  The modtime
fields on the pobox record will be set.  The owner of the target pobox
may perform this query.  Errors: MR\_USER ``No such user'' if login does
not match exactly one user, or MR\_MACHINE.

\item[delete\_pobox, dpob](login)

Effectively deletes a user's pobox, by setting the type to {\bf NONE}.
The {\em login} name must match exactly one user.  The modtime fields on
the pobox record will be set.  The owner of the target pobox may
perform this query.  Errors: MR\_USER ``No such user'' if login does not
match exactly one user.

\end{description}

\section{Machines and Clusters}

\begin{description}
\item[get\_host, ghst](name, address, location, contact) $\rightarrow$ name,
vendor, model, os, location, contact, use, status, statuschanged,
subnet, address, owner\_type, owner\_name, admin\_comment, op\_comment,
created, creator, inuse modtime, modby, modwith

Any of the arguments may contain wildcards.

\item[add\_host, ahst](name, vendor, model, os, location, contact, use,
status, subnet, address, owner\_type, owner\_name, admincomment,
opcomment)

Name will be upcased and must be unique among hosts and host aliases.
They also must meet the following sanity check: must start with a
letter, remaining chars letter, numbers, and hyphen, must not end with
a hyphen.  Vendor, model, os, and location will be upcased.  Use is an
integer whose values are determined by the client (if entity
performing the query is not on the query ACL, the use field must be
zero).  Status must be 1 (active) or 3 (reserved).  Subnet must name
an existing subnet.  Address must be unique among hosts, or ``unqiue''
or ``unassigned''.  The address must be a legal address on the subnet,
though if it is specified by the user, it need not fall within the
assignable range moira knows about.  The owner\_type must be USER,
LIST, KERBEROS, or NONE, and the owner\_name must name a valid instance
of that type.  Statuschange, created, and modtime will be set to the
current time.  Creator and modby will be set to the user.

\item[update\_host, uhst](name, newname, vendor, model, os, location,
contact, use, status, subnet, address, owner\_type, owner\_name,
acomment, ocomment, inuse)

newname must either match the old name, or be unique among hosts and
host aliases.  If the name is changed, it is sanity checked as
described in add\_host.  use may not be changed except by someone on
the query ACL.  status may be set to 1 (active), 3 (reserved) or 4
(deleted).  address may only be changed to ``unassigned'' or ``unique''
(which assigns a unique address).  If status changes, statuschange
will be set to the current date.  All other fields are as in add\_host.

\item[delete\_host, dhst](name)

Name must match exactly one entry.  If the status on that entry is 3
(deleted), then the entry will be deleted.

\item[get\_machine, gmac](name) $\rightarrow$ name, type, modtime, modby, modwith

{\bf OBSOLETE} Get all the information on the specified machine(s).
Wildcarding may be used in the machine {\em name}.  All machine names
are case insensitive, and are returned in uppercase.  It is safe for
the query ACL to be the list containing everybody.

\item[get\_hostalias, ghal](alias, host) $\rightarrow$ alias, host

Either of the arguments may contain wildcards.

\item[add\_hostalias, ahal](alias, host)

Assigns a new alias to host.  Updates the modtime on the host.

\item[delete\_hostalias, dhal](alias, host)

Removes an alias from a host.  Updates the modtime on the
host.

\item[get\_subnet, gsnt](name) $\rightarrow$ name, description, address,
mask, low, high, owner\_type, owner\_name, modtime, modby, modwith

The name argument may contain wildcards.

\item[add\_subnet, asnt](name, description, address, mask, low, high, owner\_type,
owner\_name)

Name and address each must be unique among subnets.  Owner\_type
is typechecked as an ace\_type, one of USER, KERBEROS, LIST, or NONE.
Owner\_name must name a corresponding item (users or lists must exist).

\item[update\_subnet, usnt](name, newname, description, address, mask, low, high,
owner\_type, owner\_name)

Newname and address each must be unique among subnets.  Owner\_type
is typechecked as an ace\_type, one of USER, KERBEROS, LIST, or NONE.
Owner\_name must name a corresponding item (users or lists must exist).

\item[delete\_subnet, dsnt](name)

There must be no hosts currently assigned to this subnet
before it can be removed.


\item[get\_cluster, gclu](name) $\rightarrow$ name, description, location,
modtime, modby, modwith

Returns all the information in the database about one or more
clusters.  The cluster {\em name} may contain wildcards.  It is safe for
the query ACL to be the list containing everybody.

\item[add\_cluster, aclu](name, description, location)

Adds a new cluster to the database.  The {\em name} must be unique among
the existing cluster names.  The names are case sensitive.  There are
no constraints on the remaining data.  The modtime fields will be set.
Errors: MR\_NOT\_UNIQUE ``Arguments not unique'' if the cluster {\em name}
is not unique.

\item[update\_cluster, uclu](name, newname, description, location)

Changes the information about a cluster.  The old {\em name} must match
exactly one cluster.  The {\em newname} must either match the old name
or be unique among the existing cluster names.  The names are case
sensitive.  There are no constraints on the remaining data.  The
modtime fields will be set.  Errors: MR\_CLUSTER ``Unknown cluster'' if
the old cluster name does not match exactly one cluster, or
MR\_NOT\_UNIQUE ``Arguments not unique'' if the new name does not either
match the old name or is unique.

\item[delete\_cluster, dclu](name)

Removes a cluster from the database.  The {\em name} must match exactly
one cluster.  The cluster must not have any machines assigned to it.
Any service cluster information assigned to the cluster will be
deleted.  Errors: MR\_CLUSTER ``Unknown cluster'' if the old cluster
name does not match exactly one cluster, or MR\_IN\_USE ``Object in use''
if the cluster has machines assigned to it.

\item[get\_machine\_to\_cluster\_map, gmcm](machine, cluster)
$\rightarrow$ machine, cluster

Retrieves machine to cluster mappings for the specified {\em
machine(s)\/} and {\em cluster(s)}. Either of the fields may contain
wildcards. It is safe for the query ACL to be the list containing
everybody.

\item[add\_machine\_to\_cluster, amtc](machine, cluster)

Add a machine to a cluster.  The {\em machine} name must match exactly
one machine.  The {\em cluster} name must match exactly one cluster.
The machine's modtime fields will be updated.  Errors: MR\_MACHINE ``No
such machine'' or MR\_CLUSTER ``No such cluster'' if one of them does not
match exactly one object in the database.

\item[delete\_machine\_from\_cluster, dmfc](machine, cluster)

Delete a machine from a cluster.  The {\em machine} name must match
exactly one machine.  The {\em cluster} name must match exactly one
cluster.  The named machine must belong to the named cluster.  The
machine's modtime fields will be updated.  Errors: MR\_MACHINE ``No
such machine'' or MR\_CLUSTER ``No such cluster'' if one of them does not
match exactly one object in the database.

\item[get\_cluster\_data, gcld](cluster, label) $\rightarrow$ cluster, label,
data

Retrieve all cluster data matching the named {\em cluster} and {\em label}.
Either or both may use wildcards.  Thus all data for a cluster may be
retrieved with gcld(cluster, *), and all data of a particular type may
be retrieved with gcld(*, label).  It is safe for the query ACL to be
the list containing everybody.

\item[add\_cluster\_data, acld](cluster, label, data)

Add new data to a cluster.  The {\em cluster} name must match exactly
one cluster.  The service {\em label} must be a registered {\bf slabel} in
the alias database.  The {\em data} is an arbitrary string.  The
cluster's modtime fields will be updated.  Errors: MR\_CLUSTER ``No
such cluster'' if the {\em cluster} name does not match exactly one
cluster, or MR\_TYPE ``Invalid type'' if the {\em label} is not in the
alias database.

\item[delete\_cluster\_data, dcld](cluster, label, data)

Delete the specified cluster data.  The {\em cluster} name must match
exactly one cluster, and the remaining two arguments must exactly
match an existing service cluster.  The cluster's modtime fields will
be updated.  Errors: MR\_CLUSTER ``No such cluster'' if the {\em cluster}
name does not match exactly one cluster, or MR\_NOT\_UNIQUE ``Arguments
not unique'' if the {\em label} and {\em data} do not match exactly one
existing piece of data for the cluster.

\end{description}

\section{Lists}

\begin{description}

\item[get\_list\_info, glin](list) $\rightarrow$ list, active, public, hidden,
maillist, group, gid, ace\_type, ace\_name, description, modtime, modby,
modwith

Returns information about the named list.  The {\em list} name may
contain wildcards.  {\em active, public, hidden, maillist}, and
{\em group} are booleans returned as integers (0 is false, non-zero is
true).  The {\em ace-type} is either {\bf USER}, {\bf LIST}, or {\bf NONE},
and the {\em ace\_name} will be either a login name, a list name, or
{\bf NONE}, respectively.  This query is allowed if the list is not
hidden or the user executing the query is on the ACE of the target
list.  If the user executing this query is on the query ACL, he may
use wildcards in the {\em list} name, otherwise wildcards are not
allowed.

\item[expand\_list\_names, exln](list) $\rightarrow$ list

Expands wildcards in a {\em list} name.  A name is passed which may
contain wildcards, and a set of matching names are returned.

\item[add\_list, alis](list, active, public, hidden, maillist, group, gid,
ace\_type, ace\_name, description)

Creates a new list and adds it to the database. The {\em list} name
must be unique among existing list names. {\em active, public, hidden,
maillist}, and {\em group} are booleans passed as integers (0 is
false, non-zero is true). If {\em group} is true and {\em gid} is {\bf
UNIQUE\_GID} as defined in {\em $\langle$moira.h$\rangle$}, a new
unique group ID will be assigned, otherwise the integer value given
for {\em gid} will be assigned to the GID. The {\em ace-type} is
either {\bf USER}, {\bf LIST}, or {\bf NONE}, and the {\em ace\_name}
will be either a login name, a list name, or {\bf NONE}, respectively.
The access list may be the list that is being created
(self-referential). The list modtime will be set. Errors: MR\_EXISTS
``Record already exists'' if a list already exists by that name, MR\_ACE
``No such access control entity'' if the {\em ace\_type} is not {\bf
USER}, {\bf LIST}, or {\bf NONE}, or if the {\em ace\_name} cannot be
resolved relative to the {\em ace\_type}.

\item[update\_list, ulis](list, newname, active, public, hidden, maillist,
group, gid, ace\_type, ace\_name, description)

Allows the list information and attributes to be changed. This is not
equivalent to deleting the list and creating a new one, since
references to the old name will still apply to the new name if it is
renamed. The {\em list} name must match exactly one list. The {\em new
name} must either match the old name or be unique among list names in
the database. The {\em active, public, hidden, maillist}, and {\em
group} flags should be 0 if the flag is false, or non-zero if it is
true. The {\em gid} may be {\bf UNIQUE\_GID} as defined in {\em
$\langle$moira.h$\rangle$}, in which case a new unique GID will be
assigned. The {\em ace-type} is either {\bf USER}, {\bf LIST}, or {\bf
NONE}, and the {\em ace\_name} will be either a login name, a list
name, or {\bf NONE}, respectively. The list modtime will be set. This
query may be executed by anyone on the ACE of the target list. Errors:
MR\_LIST ``No such list'' if the named list does not match exactly one
list, MR\_NOT\_UNIQUE ``Arguments not unique'' if the new list name
doesn't either match the old one or is unique, MR\_ACE ``No such access
control entity'' if the {\em ace\_type} is not {\bf USER}, {\bf LIST},
or {\bf NONE}, or if the {\em ace\_name} cannot be resolved relative to
the {\em ace\_type}.

\item[delete\_list, dlis](list)

Deletes a list from the database.  A list may only be deleted if it is
not in use as a member of any other list or as an ACL for an object,
and the list itself must be empty.  This query may be executed by
someone who is on the current ace of the target list.  Errors:
MR\_LIST ``No such list'' if the named list does not exist, or
MR\_IN\_USE ``Object is in use'' if the list is still being referenced.

\item[add\_member\_to\_list, amtl](list, type, member)

Adds a member to a list.  The specified {\em list} must match exactly
one list.  Type must be either {\bf USER}, {\bf LIST}, or {\bf STRING}.
{\em member} is either a login name, a list name, or a text string,
respectively.  The modtime on the list is updated.  This query may
be executed by: anyone adding themselves as a {\em USER} to a list with the
{\em public} bit set or anyone on the ACE of the list being modified.
Errors: MR\_LIST ``No such list'' if the named list does not exist,
MR\_TYPE ``Invalid type'' if the member {\em type} is not {\bf USER}, {\bf LIST}, or
{\bf STRING}, or MR\_NO\_MATCH ``No records in database match query'' if the
{\em member} name cannot be resolved with the member {\em type}.

\item[delete\_member\_from\_list, dmfl](list, type, member)

Deletes a member from a list.  The specified {\em list} must match exactly
one list.  The specified {\em type} and {\em member} must exactly match an
existing member of that list.  The modtime on the list is updated.
This query may be executed by anyone deleting themselves as a {\bf USER}
from a list with the {\em public} bit set or anyone on the ACE of the list
being modified.  Errors: MR\_LIST ``No such list'' if the named list
does not exist, MR\_TYPE ``Invalid type'' if the member type is not
{\bf USER}, {\bf LIST}, or {\bf STRING}, or MR\_NO\_MATCH ``No records in database
match query'' if the {\em member} name cannot be resolved with the member
{\em type} or if there is no such member in the list.

\item[get\_ace\_use, gaus](ace\_type, ace\_name) $\rightarrow$ object\_type, object\_name

Finds references to an object as an ACE.  Valid {\em ace\_types} are
{\bf USER}, {\bf LIST}, {\bf RUSER}, and {\bf RLIST}.  For types {\bf USER} and
{\bf RUSER}, the {\em ace\_name} must be a login name.  If the type is
{\bf USER}, then only objects whose ACE is the named user will be found;
if it is {\bf RUSER}, it will recursively check down sub-lists of the
ACE lists looking to see if the user is a member of that ACE.  The
types {\bf LIST} and {\bf RLIST} apply to a list name in a similar manner.
The returned tuples will be {\bf LIST}, list name; {\bf SERVICE}, service
name; {\bf FILESYS} and a filesystem label; {\bf QUERY}, query name;
{\bf HOSTACCESS}, machine name; or {\bf ZEPHYR}, zephyr class name.  This
query may be executed by a user asking about himself or a person on an
ACE of a list asking about that list.  Errors: MR\_TYPE ``Invalid type''
if the {\em ace\_type} is not one of {\bf LIST}, {\bf RLIST}, {\bf USER}, or
{\bf RUSER}; MR\_NO\_MATCH ``No objects in database match query'' if the
{\em ace\_name} doesn't match a user or list.

\item[qualified\_get\_lists, qgli](active, public, hidden, maillist,
group) $\rightarrow$ list

Finds the names of any lists that meet the specified criteria.  Each
of the inputs may be one of {\bf TRUE, FALSE}, or {\bf DONTCARE}.  Any
user may execute this query with {\em active} {\bf TRUE} and {\em hidden}
{\bf FALSE}.  Errors: MR\_TYPE ``Invalid type'' if one of the arguments is
something other than {\bf TRUE}, {\bf FALSE}, or {\bf DONTCARE}.

\item[get\_members\_of\_list, gmol](list) $\rightarrow$ type, value

Retrieves all of the members of the named list.  The {\em list} must
match exactly one list in the database.  The returned pairs consist of
the type {\bf USER}, {\bf LIST}, or {\bf STRING}, followed by the login
name, list name, or text string respectively.  This query may be
executed by anyone if the list is not hidden; otherwise by someone on
the ACE of the list being modified.

\item[get\_lists\_of\_member, glom](type, value) $\rightarrow$ list, active,
public, hidden, maillist, group

Retrieves the name and flags of every list containing the named
member.  The member {\em type} must be one of {\bf USER}, {\bf LIST}, or
{\bf STRING}, and the {\em value} a login name, list name, or text string
respectively.  The {\em type} may also be one of {\bf RUSER, RLIST}, or
{\bf RSTRING}, in which case it will also find any lists that contain as
sublists a list that the target is a member of.  This query may be
executed by someone asking about themselves or a person on the ace of
a list asking about that list.  Errors: MR\_TYPE ``Invalid type'' if the
{\em type} is not {\bf USER, LIST, STRING, RUSER, RLIST}, or {\bf RSTRING};
or MR\_NO\_MATCH ``No records in database match query'' if {\em value} does
not match an existing value for the given type.

\item[count\_members\_of\_list, cmol](list) $\rightarrow$ count

Determines how many members are on the specified list.  The {\em list}
name must match exactly one list.  This query may be executed by a
anyone on a visible list, or someone on the ACE of the target list.
MR\_LIST ``Invalid list'' if the list name does not match exactly one
list.

\end{description}

\section{DCM Information}

\begin{description}

\item[get\_server\_info, gsin](name) $\rightarrow$ service, interval, target,
script, dfgen, dfcheck, type, enable, inprogress, harderror, errmsg,
ace\_type, ace\_name, modtime, modby, modwith

Retrieves service information from the database.  This is the
per-service information used by the DCM for updates.  The service
{\em name} may contain wildcards.  Note that all service names are
stored in uppercase, and the passed name will be upper-cased before
comparing it.  The returned {\em interval} is in minutes.  {\em dfgen} is
the data files were last generated, and {\em dfcheck} is the date we
last checked to see if we needed to generate them.  These are passed
as integers (unix format date).  The {\em type} must be a
{\bf service-type} as stored in the aliases database.  {\em enable,
inprogress}, and {\em harderror} are booleans (0 = false, non-zero =
true).  {\em ace\_type} is either {\bf USER, LIST}, or {\bf NONE}, and
{\em ace\_name} is a login name, a list name, or {\bf NONE}, respectively.
This query may be executed by someone on the service ace if only one
service is retrieved.

\item[qualified\_get\_server, qgsv](enable, inprogress, harderror)
$\rightarrow$ service

Finds the names of any services that meet the specified criteria.
Each of the inputs may be one of {\bf TRUE, FALSE}, or {\bf DONTCARE}.
Errors: MR\_TYPE ``Invalid type'' if any of the flags are not one of the
three legal values.

\item[add\_server\_info, asin](service, interval, target, script, type, enable,
ace\_type, ace\_name)

Adds a new service to the database.  This is the per-service
information used by the DCM for updates.  Note that only a subset of
the information is added in this query, as the remaining fields are
only changed by the DCM with the {\em set\_server\_internal\_flags} query.
The {\em service} name will be converted to uppercase.  The {\em interval}
is in minutes.  The {\em type} must be a {\bf service-type} as stored in
the aliases database.  {\em Enable} is a boolean (0 = false, non-zero =
true).  {\em ace\_type} is either {\bf USER, LIST}, or {\bf NONE}, and
{\em ace\_name} is a login name, a list name, or {\bf NONE}, respectively.
The service modtime will be set.  Errors: MR\_TYPE ``Invalid type'' if
the type field is not a valid {\bf service-type} in the alias database,
or MR\_ACE ``No such access control entity'' if the {\em ace\_type} is not
{\bf USER, LIST}, or {\bf NONE} or the {\em ace\_name} cannot be resolved
based on the {\em ace\_type}.

\item[update\_server\_info, usin](service, interval, target, script, type,
enable, ace\_type, ace\_name)

Updates a service in the database.  This is the per-service
information used by the DCM for updates.  Note that only a subset of
the information can be modified with this query, as the remaining
fields are only changed by Moira itself.  The {\em service} name must
match exactly one existing service after being converted to uppercase.
The {\em interval} is in minutes.  The {\em type} must be a
{\bf service-type} as stored in the aliases database.  {\em Enable} is a
boolean (0 = false, non-zero = true).  {\em Ace\_type} is either {\bf USER,
LIST}, or {\bf NONE}, and {\em ace\_name} is a login name, a list name, or
{\bf NONE}, respectively.  The service modtime will be set.  This query
may be used by someone on the ACE of the target service.  Errors:
MR\_TYPE ``Invalid type'' if the {\em type} field is not a valid
{\bf service-type} in the alias database, or MR\_ACE ``No such access
control entity'' if the {\em ace\_type} is not {\bf USER, LIST}, or {\bf NONE}
or the {\em ace\_name} cannot be resolved based on the {\em ace\_type}.

\item[reset\_server\_error, rsve](service)

Updates the specified service by changing the harderror flag from
{\bf TRUE} to {\bf FALSE}, and sets {\em dfcheck} to be the same as
{\em dfgen}.  The {\em service} name must match exactly on existing
service after being converted to uppercase.  The service modtime will
be set.  This query may be executed by someone on the ACE of the
target service.

\item[set\_server\_internal\_flags, ssif](service, dfgen, dfcheck,
inprogress, harderr, errmsg)

Updates the specified service.  This is intended to only be used by
the DCM, as it changes flags that the user should not have control
over.  The {\em service} name must match exactly one existing service
after being converted to uppercase.  {\em dfgen} and {\em dfcheck} are
unix format dates (long integers).  {\em inprogress} and {\em harderr} are
booleans (0 = false, non-zero = true).  The service modtime will NOT
be set.

\item[delete\_server\_info, dsin](service)

Deletes a set of service information from the database.  The
{\em service} name must match exactly one service in the database after
being converted to uppercase.  A service may not be deleted if there
are any server-hosts assigned to that service, or if the inprogress
bit is set for that service.  Error: MR\_IN\_USE ``Object is in use'' if
there are hosts assigned to that service.

\item[get\_server\_host\_info, gshi](service, machine) $\rightarrow$ service,
machine, enable, override, success, inprogress, hosterror, errmsg,
lasttry, lastsuccess, value1, value2, value3, modtime, modby, modwith

Retrieves server-host information from the database.  This is the
per-host information used by the DCM for updates.  The given
{\em service} and {\em machine} names may contain wildcards.  {\em Enable,
override, success, inprogress}, and {\em hosterror} are booleans (0 =
false, non-zero = true).  {\em lasttry} and {\em lastsuccess} are unix
format dates (long integers).  This query may be executed by someone
on the ACE for the target service.

\item[qualified\_get\_server\_host, qgsh](service, enable, override, success,
inprogress, hosterror) $\rightarrow$ service, machine

Finds the names of any machine/services pairs that meet the specified
criteria.  The {\em service} name may contain wildcards.  Each of the
remaining inputs may be one of {\bf TRUE, FALSE}, or {\bf DONTCARE}.
Errors: MR\_TYPE ``Invalid type'' if any of the flags are not one of the
three legal values.

\item[add\_server\_host\_info, ashi](service, machine, enable, value1, value2,
value3)

Adds information for a new server-host to the database.  This is the
per-host information used by the DCM for updates.  Note that only a
subset of the information is dealt with in this query, as the
remaining fields are only changed by the DCM with the
{\em set\_server\_host\_internal} query.  {\em Service} and {\em machine} must
each match exactly one existing service and machine, respectively.
{\em Enable} is a boolean (0 = false, non-zero = true).  The 3 values
are service specific in function; {\em value1} and {\em value2} are
integers, {\em value3} is a string.  The server-host's modtime will be
set.  This query may be used by someone on the ACE for the target
service.  Errors: MR\_SERVICE ``Unknown service'' if the {\em service}
name does not match exactly one existing service, or MR\_MACH ``Invalid
machine'' if the {\em machine} name does not match exactly one machine.

\item[update\_server\_host\_info, ushi](service, machine, enable, value1,
value2, value3)

Updates information for a server-host in the database.  This is the
per-host information used by the DCM for updates.  Note that only a
subset of the information is dealt with in this query, as the
remaining fields are only changed by the DCM with the
{\em set\_server\_host\_internal} query.  {\em Service} and {\em machine} must
each match exactly one existing service and machine, respectively.
{\em Enable} is a boolean (0 = false, non-zero = true).  The 3 values
are service specific in function; {\em value1} and {\em value2} are
integers, {\em value3} is a string.  The server-host's modtime will be
set.  This query may only be executed when the inprogress bit is not
currently set for the specified server\_host.  This query may be used
by someone on the ACE for the target service.  Errors: MR\_SERVICE
``Unknown service'' if the {\em service} name does not match exactly one
existing service, or MR\_MACH ``Invalid machine'' if the {\em machine}
name does not match exactly one machine.


\item[reset\_server\_host\_error, rshe](service, machine)

Resets the hosterr flag for the specified server\_host.  The
{\em service} and {\em machine} must each match exactly one service and
host.  The server\_host's modtime will be updated.  This query may be
used by someone on the ACE for the target service.  Errors:
MR\_SERVICE ``Unknown service'' if the {\em service} name does not match
exactly one existing service, or MR\_MACH ``Invalid machine'' if the
{\em machine} name does not match exactly one machine.

\item[set\_server\_host\_override, ssho](service, machine)

This will set the override flag for a server\_host, and start a new DCM
running.  The {\em service} and {\em machine} must each match exactly one
service and host.  The server\_host's modtime will be updated.  This
query may be used by someone on the ACE for the target service.
Errors: MR\_SERVICE ``Unknown service'' if the {\em service} name does not
match exactly one existing service, or MR\_MACH ``Invalid machine'' if
the {\em machine} name does not match exactly one machine.

\item[set\_server\_host\_internal, sshi](service, machine, override,
success, inprogress, hosterror, errmsg, lasttry, lastsuccess)
$\rightarrow$

Updates the specified service\_host.  This is intended to only be used
by the DCM, as it changes flags that the user should not have control
over.  The {\em service} and {\em host} names name must match exactly one
existing service and host each.  {\em override, success, inprogress} and
{\em hosterror} are booleans (0 = false, non-zero = true).  {\em lasttry}
and {\em lastsuccess} are unix format dates (long integers).  The
service\_host modtime will NOT be set.  Errors: MR\_SERVICE ``Unknown
service'' if the {\em service} name does not match exactly one existing
service, or MR\_MACH ``Invalid machine'' if the {\em machine} name does
not match exactly one machine

\item[delete\_server\_host\_info, dshi](service, machine)

Deletes a server-host from the database.  The {\em service} and
{\em machine} names each must match exactly one existing service or
host.  A server-host may not be deleted if the inprogress bit is set
for that server-host.  This query may be used by someone on the ACE
for the target service.  Errors: MR\_SERVICE ``Unknown service'' if the
{\em service} name does not match exactly one existing service, MR\_MACH
``Invalid machine'' if the {\em machine} name does not match exactly one
machine, or MR\_IN\_USE ``Object is in use'' if the inprogress bit is
set.

\item[get\_server\_locations, gslo](service) $\rightarrow$ service, machine

This query tells which machines support a given service.  It does this
by listing each of the server-hosts for that service.  The {\em service}
name may contain wildcards, and will be converted to uppercase before
any comparisons are made.  It is safe for this query's ACL to be the
list containing everybody.

\end{description}

\section{Filesystems}

\begin{description}

\item[ get\_filesys\_by\_label, gfsl](name) $\rightarrow$ name, fstype,
machine, packname, mountpoint, access, comments, owner, owners,
create, lockertype, modtime, modby, modwith

Retrieves all the information about a specific filesystem from the
database.  The {\em name} may contain wildcards.  {\em fstype} is one of
{\bf NFS}, {\bf RVD}, {\bf FSGROUP}, or {\bf ERR}, recorded as aliases of
{\bf filesys}.  {\em machine} must match exactly one existing machine.
{\em owner} must match exactly one user, {\em owners} must match exactly
one list.  {\em create} is a boolean (0 = false, non-zero = true)
indicating that the locker should be automatically created.
{\em lockertype} is a {\bf lockertype} as recorded in the alias database,
currently one of {\bf SYSTEM, HOMEDIR, PROJECT}, or {\bf OTHER}.  The
{\em packname, mountpoint}, and {\em access} vary depending on the
filesystem type.

\item[get\_filesys\_by\_machine, gfsm](machine) $\rightarrow$ name, fstype,
machine, packname, mountpoint, access, comments, owner, owners,
create, lockertype, modtime, modby, modwith

Retrieves the information about any filesystems on the named machine.
The {\em machine} name must match exactly one machine in the database.
The returned information is as specified above for
{\em get\_filesys\_by\_label}.  Errors: MR\_MACHINE ``No such machine'' if
the named machine does not match an existing machine.

\item[get\_filesys\_by\_nfsphys, gfsn](machine, partition)
$\rightarrow$ name, fstype, machine, packname, mountpoint, access, comments,
owner, owners, create, lockertype, modtime, modby, modwith

Retrieves the information about all NFS filesystems that reside on the
specified NFS server partition.  {\em machine} must match exactly one
machine.  {\em partition} is the mount point of the NFS physical
partition.  Errors: MR\_MACHINE ``Invalid machine'' if the machine name
does not match exactly one machine, or MR\_NO\_MATCH ``No records in
database match query'' if the partition does not match anything.

\item[get\_filesys\_by\_group, gfsg](list) $\rightarrow$ name, fstype,
machine, packname, mountpoint, access, comments, owner, owners,
create, lockertype, modtime, modby, modwith

Retrieves the information about all filesystems that have the
specified group as the owners list.  The {\em list} must match exactly
one existing list.  This query may be executed by a member of the
target list.  Errors: MR\_LIST ``No such list'' if the given list does
not match exactly one list in the database.

\item[get\_filesys\_by\_path, gfsp](path) $\rightarrow$ name, fstype,
machine, packname, mountpoint, access, comments, owner, owners,
create, lockertype, modtime, modby, modwith

Retrieves the information about all filesystems that have the
specified path as the packname.  This query may be executed by a
member of the target list.  Errors: MR\_LIST ``No such list'' if the
given list does not match exactly one list in the database.

\item[add\_filesys, afil](name, fstype, machine, packname, mountpoint,
access, comments, owner, owners, create, lockertype)

Adds a new filesystem to the database.  The {\em name} must be unique
among the existing filesystems.  {\em fstype} is one of {\bf NFS} or
{\bf RVD}.  {\em machine} must match exactly one existing machine.
{\em owner} must match exactly one user, {\em owners} must match exactly
one list.  {\em create} is a boolean (0 = false, non-zero = true)
indicating that the locker should be automatically created.
{\em lockertype} is a {\bf lockertype} as recorded in the alias database,
currently one of {\bf SYSTEM, HOMEDIR, PROJECT}, or {\bf OTHER}.  The
{\em packname} and {\em access} vary depending on the filesystem type.
For an RVD filesystem, they may contain anything.  For NFS
filesystems, the {\em packname} must match an existing NFS physical
filesystem, and {\em access} must be one of {\bf r} or {\bf w}.  The
filesystem's modtime will be set.  Errors: MR\_FSTYPE ``Invalid filesys
type'' if the {\em fstype} is not a valid {\bf filesys} type, MR\_TYPE
``Invalid type'' if the {\em lockertype} is not a valid {\bf lockertype},
MR\_MACHINE ``No such machine'' if the {\em machine} name does not match
exactly one machine, MR\_USER ``No such user'' if the {\em owner} does not
match exactly one user, MR\_LIST ``No such list'' if the {\em owners} does
not match exactly one list, MR\_NFS ``Specified directory not exported''
if the {\em machine} and {\em packname} do not match an existing NFS
physical partition, or MR\_FILESYS\_ACCESS if the {\em fstype} is {\bf NFS}
and the access mode is not {\bf r} or {\bf w}.

\item[update\_filesys, ufil](name, newname, fstype, machine, packname,
mountpoint, access, comments, owner, owners, create, lockertype)
$\rightarrow$

Updates the information about a filesystem in the database.  The
{\em name} must match exactly one existing filesystem.  The {\em new name}
must either match the existing one or be unique among the filesystems.
{\em fstype} is one of {\bf NFS} or {\bf RVD}.  {\em machine} must match
exactly one existing machine.  {\em owner} must match exactly one user,
{\em owners} must match exactly one list.  {\em create} is a boolean (0 =
false, non-zero = true) indicating that the locker should be
automatically created.  {\em lockertype} is a {\bf lockertype} as recorded
in the alias database, currently one of {\bf SYSTEM, HOMEDIR, PROJECT},
or {\bf OTHER}.  The {\em packname} and {\em access} vary depending on the
filesystem type.  For an {\bf RVD} filesystem, they may contain
anything.  For {\bf NFS} filesystems, the {\em packname} must match an
existing NFS physical filesystem, and {\em access} must be one of {\bf r}
or {\bf w}.  The filesystem's modtime will be updated.  Errors:
MR\_NOT\_UNIQUE ``Arguments not unique'' if the {\em new name} does not
either match the old one or is unique among filesystems, MR\_FSTYPE
``Invalid filesys type'' if the {\em fstype} is not a valid {\bf filesys}
type, MR\_TYPE ``Invalid type'' if the {\em lockertype} is not a valid
{\bf lockertype}, MR\_MACHINE ``No such machine'' if the {\em machine} name
does not match exactly one machine, MR\_USER ``No such user'' if the
{\em owner} does not match exactly one user, MR\_LIST ``No such list'' if
the {\em owners} does not match exactly one list, MR\_NFS ``Specified
directory not exported'' if the {\em machine} and {\em packname} do not
match an existing NFS physical partition, or MR\_FILESYS\_ACCESS if the
{\em fstype} is {\bf NFS} and the {\em access} mode is not {\bf r} or {\bf w}.

\item[delete\_filesys, dfil](name)

Deletes a filesystem from the database.  The {\em name} must match
exactly one existing filesystem.  Any quotas assigned to that
filesystem will be deleted, and the allocation count on the nfs
physical partition will be decremented accordingly.  Errors:
MR\_FILESYS ``No such file system'' if the name does not match an
existing filesystem.

\item[get\_fsgroup\_members, gfgm](name) $\rightarrow$ filsys, sortkey

Fetches the filesystems belonging to the named fsgroup.  The
filesystems will be returned in sort order.  The {\em name} must match
exactly one existing fsgroup.  Errors: MR\_FILESYS ``No such file
system'' if the name does not match an existing fsgroup.

\item[add\_filesys\_to\_fsgroup, aftg](fsgroup, filesys, sortkey)

Adds the named filesystem to the named fsgroup, with the given
sortkey.  The {\em filesys} and {\em fsgroup} must each match exactly one
existing filesystem.  Errors: MR\_FILESYS ``No such file system'' if the
name does not match an existing fsgroup.

\item[remove\_filesys\_from\_fsgroup, rffg](filesys, fsgroup)

Deletes the named filesystem from the named fsgroup.  The {\em filesys}
and {\em fsgroup} must each match exactly one existing filesystem.
Errors: MR\_FILESYS ``No such file system'' if the name does not match
an existing fsgroup, MR\_NO\_MATCH if the filesystem is not a member of
the group.

\item[get\_all\_nfsphys, ganf]() $\rightarrow$ machine, dir, device, status,
allocated, size, modtime, modby, modwith

Retrieves information about NFS physical filesystems.  These are the
filesystems which are exported by NFS servers.

\item[get\_nfsphys, gnfp](machine, dir) $\rightarrow$ machine, dir, device,
status, allocated, size, modtime, modby, modwith

Retrieves information about a specific NFS physical filesystem.  The
{\em machine} must match exactly one existing machine.  The
{\em dir}ectory name may contain wildcards.  Errors: MR\_MACHINE ``No
such machine'' if the {\em machine} name does not match exactly one
existing machine.

\item[add\_nfsphys, anfp](machine, directory, device, status, allocated,
size)

Adds a new NFS physical filesystem to the database.  The {\em machine}
name must match exactly one existing machine.  The {\em directory} and
{\em device} must be unique among existing NFS physical filesystems for
this machine.  {\em status} is an integer, with bit encodings
{\bf MR\_FS\_STUDENT, MR\_FS\_FACULTY, MR\_FS\_STAFF}, or {\bf MR\_FS\_MISC}
as defined in {\em $\langle$moira.h$\rangle$}.  {\em allocated} keeps track of quota
allocation, the initial value should be zero unless there is something
besides lockers on this filesystem.  {\em size} is the actual size (in
blocks) of the filesystem.  The modtime will be set for this
filesystem.  Errors: MR\_MACHINE ``No such machine'' if the {\em machine}
name does not match exactly one existing machine.

\item[update\_nfsphys, unfp](machine, directory, device, status,
allocated, size)

Changes information about an NFS physical filesystem in the database.
The {\em machine} name must match exactly one existing machine.  The
{\em directory} must match an existing NFS physical filesystem on that
machine.  The remaining arguments will replace the current values of
those fields.  The modtime will be updated for this filesystem.
Errors: ``No such machine'' if the {\em machine} name does not match
exactly one existing machine.

\item[adjust\_nfsphys\_allocation, ajnf](machine, directory, delta)

Changes the allocation for an NFS physical filesystem.  {\em machine}
must match exactly one existing machine.  {\em directory} must match an
existing NFS physical filesystem on that machine.  The current
allocation for this filesystem will have {\em delta} (which may be
positive or negative) added to it.  Errors: MR\_MACHINE ``No such
machine'' if the {\em machine} name does not match exactly one existing
machine.

\item[delete\_nfsphys, dnfp](machine, directory)

Deletes an NFS physical filesystem from the database.  The {\em machine}
name must match exactly one existing machine.  The {\em directory} name must
match exactly one existing NFS physical filesystem on that machine.
The physical filesystem must not be in use with logical filesystems.
Errors: MR\_MACHINE ``No such machine'' if the {\em machine} name does not
match exactly one existing machine, or MR\_IN\_USE ``Object is in use''
if there are any filesystems assigned to this partition.

\item[get\_quota, gqot](filesys, type, name) $\rightarrow$ filesys,
type, name, quota, directory, machine, modtime, modby, modwith

Retrieves the quotas assigned to the named filesystem(s) and quota
holder.  Valid types are {\bf USER}, {\bf GROUP}, and {\bf ANY} with
corresponding login name, list name, or any placeholder.  The
{\em filesystem} name may contain wildcards.  Errors: MR\_TYPE ``Invalid
type'' if the type is not a valid ``quota\_type'' in the alias table.

\item[get\_quota\_by\_filesys, gqbf](filesys) $\rightarrow$ filesys,
type, name, quota, directory, machine, modtime, modby, modwith

Retrieves the quotas assigned to the named filesystem(s).  The
{\em filesystem} name may contain wildcards.

\item[add\_quota, aqot](filesystem, type, name, quota)

Adds a new quota to the database.  The {\em filesystem} name must match
exactly one existing filesystem.  Valid types are {\bf USER}, {\bf GROUP},
and {\bf ANY} with corresponding login name, list name, or ``*''.  The
{\em quota} may be any positive integer.  The modtime on the quota
record will be set.  If the filesystem is of type NFS, the allocation
count for that NFS physical partition will also be updated.  Errors:
MR\_FILESYS ``No such file system'' if the {\em filesystem} does not match
exactly one existing filesystem, or MR\_TYPE ``Invalid type'' if the type
is not a valid ``quota\_type'' in the alias table.

\item[update\_quota, uqot](filesystem, type, name, quota)

Changes a quota in the database.  The {\em filesystem} name must match
exactly one existing filesystem.  Valid types are {\bf USER}, {\bf GROUP},
and {\bf ANY} with corresponding login name, list name, or ``*'', and that
entity must have a quota on the named filesystem.  The quota may be
any positive integer, and will replace the existing quota.  The
modtime on the quota record will be set.  If the filesystem is of type
NFS, the allocation count for that NFS physical partition will also be
updated.  Errors: MR\_FILESYS ``No such file system'' if the
{\em filesystem} does not match exactly one existing filesystem, or
MR\_TYPE ``Invalid type'' if the type is not a valid ``quota\_type'' in the
alias table.

\item[delete\_quota, dqot](filesystem, type, name)

Deletes a quota from the database.  The {\em filesystem} name must match
exactly one existing filesystem.  Valid types are {\bf USER}, {\bf GROUP},
and {\bf ANY} with corresponding login name, list name, or ``*'', and that
entity must have a quota on the named filesystem.  If the filesystem
is of type NFS, the allocation count for that NFS physical partition
will also be updated.  Errors: MR\_FILESYS ``No such file system'' if the
{\em filesystem} does not match exactly one existing filesystem, or
MR\_TYPE ``Invalid type'' if the type is not a valid ``quota\_type'' in the
alias table.

\item[get\_nfs\_quota, gnfq](filesys, login) $\rightarrow$ filesys,
login, quota, directory, machine, modtime, modby, modwith

{\bf Obsolete.}
Retrieves the quotas assigned to the named filesystems and user.  The
{\em filesystem} name may contain wildcards.  The {\em login} name must
match exactly one user.  This query may be executed by the owner of
the target filesystem.

\item[get\_nfs\_quotas\_by\_partition, gnqp](machine, directory)
filesys, login, quota, directory, machine

Retrieves the quotas assigned to a given device.  The {\em machine} must
match exactly one existing machine.  The {\em directory} name may
contain wildcards.  Errors: MR\_MACHINE ``No such machine'' if the
{\em machine} name does not match exactly one existing machine.

\item[add\_nfs\_quota, anfq](filesystem, login, quota)

{\bf Obsolete.}
Adds a new quota to the database.  The {\em filesystem} name must match
exactly one existing filesystem.  The {\em login} name must match
exactly one existing user.  The {\em quota} may be any positive
integer.  The modtime on the quota record will be set.  The allocation
count for that NFS physical filesystem will also be updated.  Errors:
MR\_FILESYS ``No such file system'' if the {\em filesystem} does not match
exactly one existing filesystem, or MR\_USER ``No such user'' if the
{\em login} name does not match exactly one existing user.

\item[update\_nfs\_quota, unfq](filesystem, login, quota)

{\bf Obsolete.}
Changes a quota in the database.  The {\em filesystem} name must match
exactly one existing filesystem.  The {\em login} name must match
exactly one existing user, and that user must have a quota assigned on
that filesystem.  The quota may be any positive integer, and will
replace the existing quota.  The modtime on the quota record will be
set.  The allocation count for that NFS physical filesystem will also
be updated.  Errors: MR\_FILESYS ``No such file system'' if the
{\em filesystem} does not match exactly one existing filesystem, or
MR\_USER ``No such user'' if the {\em login} name does not match exactly
one existing user.

\item[delete\_nfs\_quota, dnfq](filesystem, login)

{\bf Obsolete.}
Deletes a quota from the database.  The {\em filesystem} name must match
exactly one existing filesystem.  The {\em login} name must match
exactly one existing user, and that user must have a quota assigned on
that filesystem.  The allocation count for that NFS physical
filesystem will also be updated.  Errors: MR\_FILESYS ``No such file
system'' if the {\em filesystem} does not match exactly one existing
filesystem, or MR\_USER ``No such user'' if the {\em login} name does not
match exactly one existing user.

\end{description}

\section{Zephyr}

\begin{description}

\item[get\_zephyr\_class, gzcl](class) $\rightarrow$ class, xmttype, xmtname,
subtype, subname, iwstype, iwsname, iuitype, iuiname, modtime, modby,
modwith

Retrieves zephyr class information from the database.  The {\em class}
name may contain wildcards.  There are four pairs of types and names:
each type is one of {\bf USER, LIST}, or {\bf NONE}, and each name is a
login name, a list name, or {\bf NONE}, respectively.

\item[add\_zephyr\_class, azcl](class, xmttype, xmtname, subtype, subname,
iwstype, iwsname, iuitype, iuiname)

Adds a new zephyr class to the database.  The {\em class} name must be
unique among the existing class names.  There are four pairs of types
and names: each type is one of {\bf USER, LIST}, or {\bf NONE}, and each
name is a login name, a list name, or {\bf NONE}, respectively.  The
class's modtime will be updated.

\item[update\_zephyr\_class, uzcl](class, newclass, xmttype, xmtname, subtype,
subname, iwstype, iwsname, iuitype, iuiname)

Change a zephyr class in the database.  The {\em class} name must match
exactly one existing class.  The {\em new class} name must either match
the old one or be unique among the existing class names.  There are
four pairs of types and names: each type is one of {\bf USER, LIST}, or
{\bf NONE}, and each name is a login name, a list name, or {\bf NONE},
respectively.  The class's modtime will be updated.

\item[delete\_zephyr\_class, dzcl](class)

Deletes a zephyr class from the database.  The {\em class} name must
match exactly one existing class.

\end{description}

\section{Miscellaneous}

\begin{description}

\item[get\_server\_host\_access, gsha](machine) $\rightarrow$ machine,
ace\_type, ace\_name, modtime, modby, modwith

Returns information about who has access to a given machine.  This
will be used to load the {\em /.klogin} file on that machine.  The
{\em machine} name may contain wildcards.  The {\em ace\_type} is either
{\bf USER}, {\bf LIST}, or {\bf NONE}, and the {\em ace\_name} is either a
login name, a list name, or {\bf NONE}, respectively.

\item[add\_server\_host\_access, asha](machine, ace\_type, ace\_name)

Adds information about who has access to a given machine to the
database.  The {\em machine} name must match exactly one existing
machine.  The {\em ace\_type} is either {\bf USER, LIST}, or {\bf NONE}, and
the {\em ace\_name} is either a login name, a list name, or {\bf NONE},
respectively.  The modtime on the record will be set.  Errors:
MR\_MACHINE ``No such machine'' if the {\em machine} name does not match
exactly one existing machine, MR\_ACE ``Invalid access control entity''
if the {\em ace\_type} and {\em ace\_name} together do not specify a valid
entity.

\item[update\_server\_host\_access, usha](machine, ace\_type, ace\_name)
$\rightarrow$

Updates the information about who has access to a given machine.  The
{\em machine} name must match exactly one existing machine.  The
{\em ace\_type} is either {\bf USER, LIST}, or {\bf NONE}, and the
{\em ace\_name} is either a login name, a list name, or {\bf NONE},
respectively.  The modtime on the record will be updated.  Errors:
MR\_MACHINE ``No such machine'' if the {\em machine} name does not match
exactly one existing machine, MR\_ACE ``Invalid access control entity''
if the {\em ace\_type} and {\em ace\_name} together do not specify a valid
entity.

\item[delete\_server\_host\_access, dsha](machine)

Updates the information about who has access to a given machine.  The
{\em machine} name must match exactly one existing machine.

\item[get\_service, gsvc](service) $\rightarrow$ service, protocol, port, description

Retrieves information about a network service.  The service name may
contain wildcards.  It is safe for this query's ACL to be the list
containing everybody.

\item[add\_service, asvc](service, protocol, port, description)

Adds information about a new network service to the database.  The
service name must not match any existing services.  The protocol must
be listed as a ``protocol'' in the aliases database, currently ``UDP'' and
``TCP''.

\item[delete\_service, dsvc](service)

Deletes information about a network service from the database.  The
service name must match exactly one existing service.

\item[get\_printcap\_entry, gpce](printer) $\rightarrow$ printer, spool\_host,
spool\_directory, rprinter, quotaserver, authenticate, price, comments,
modtime, modby, modwith

Retrieves information about a printer.  The {\em printer} name may
contain wildcards.  It is safe for this query's ACL to be the list
containing everybody.

\item[add\_printcap\_entry, apce](printer, spool\_host, spool\_directory,
rprinter, quotaserver, authenticate, price, comments)

Adds information about a new printer to the database.  The {\em printer}
name must not match any existing printers.  {\em spool\_host} and
{\em quotaserver} each must name exactly one existing machine in the
database.  The printer's modtime will be set.  Error: MR\_MACHINE if
{\em spool\_host} or {\em quotaserver} do not each match exactly one
machine.

\item[delete\_printcap\_entry, dpce](printer)

Deletes information about a printer from the database.  The
{\em printer} name must match exactly one existing printer.

\item[get\_printcap, gpcp](printer) $\rightarrow$ printer, spool\_host,
spool\_directory, rprinter, comments, modtime, modby, modwith

{\bf Obsolete.}
Retrieves information about a printer.  The {\em printer} name may
contain wildcards.  It is safe for this query's ACL to be the list
containing everybody.

\item[add\_printcap, apcp](printer, spool\_host, spool\_directory,
rprinter, comments)

{\bf Obsolete.}
Adds information about a new printer to the database.  The {\em printer}
name must not match any existing printers.  {\em spool\_host} must name
exactly one existing machine in the database.  The printer's modtime
will be set.  Error: MR\_MACHINE if {\em spool\_host} does not match
exactly one machine.

\item[delete\_printcap, dpcp](printer)

{\bf Obsolete.}
Deletes information about a printer from the database.  The
{\em printer} name must match exactly one existing printer.

\item[get\_palladium, gpdm](name) $\rightarrow$ name, ident, machine,
modtime, modby, modwith

Gets information about palladium servers and supervisors.  {\em Name}
may contain wildcards.

\item[add\_palladium, apdm](name, ident, machine)

Adds information about a new palladium server or supervisor.  {\em Ident} is
the 16-bit port identifier, and {\em machine} must name an existing
machine.  Error: MR\_MACHINE if {\em machine} does not match exactly one
machine.

\item[delete\_palladium, dpdm](name)

Deletes information about a new palladium server or supervisor.

\item[get\_alias, gali](name, type, translation) $\rightarrow$ name, type,
translation

Looks up an alias in the alias database.  This database is used both
for user information like alternate names of filesystems, and keyword
validation for various queries.  Note that type validation entries are
of the form ({\em [type name, usually in lower case]}, {\bf TYPE},
{\em [type string, always in upper case]}).  Some type validation
entries are used to further identify another field.  These have
entries of the form ({\em [type string in uppercase]}, {\bf TYPEDATA},
{\em [type, one of: {\bf none, user, list, string, machine)]}}.  The
{\em name, type}, and {\em translation} may contain wildcards.  It is safe
for this query to be the list containing everybody.

\item[add\_alias, aali](name, type, translation)

Adds a new alias to the alias database.  The {\em type} must be a known
type as recorded under {\bf alias} in the alias database.  Duplicate
translations for a given (name, type) pair are allowed.  Note that
type validation entries are of the form ({\em [type name, usually in
lower case]}, {\bf TYPE}, {\em [type string, always in upper case]}).
Some type validation entries are used to further identify another
field.  These have entries of the form ({\em [type string in
uppercase]}, {\bf TYPEDATA}, {\em [type, one of: {\bf none, user, list,
string, machine)]}}.  The {\em name, type}, and {\em translation} may
contain wildcards.

\item[delete\_alias, dali](name, type, translation)

Deletes an alias from the alias database.  The combination of all
three input arguments must match exactly one alias.

\item[get\_value, gval](variable) $\rightarrow$ value

Look up a value in the values database.  This is used for DCM flags
and Moira internal ID hints.  The {\em variable} name must match exactly
one existing value name in the database.  It is safe for this query's
ACL to be the list containing everybody.  Errors: MR\_NO\_MATCH ``No
records in database match query'' if the name does not match exactly
one variable name.

\item[add\_value, aval](variable, value)

Adds a new value to the values database.  The {\em variable} name must
be unique among the variables already in the database.  The {\em value}
is an integer.

\item[update\_value, uval](variable, value)

Changes the value of an existing variable in the values database.  The
{\em variable} name must match exactly one existing variable.  Its
{\em value} will be replaced with the supplied value.  Errors:
MR\_NO\_MATCH ``No records in database match query'' if the name does not
match exactly one variable name.

\item[delete\_value, dval](variable)

Deletes a variable from the values database.  The {\em variable} name
must match exactly one existing variable.  Errors: MR\_NO\_MATCH ``No
records in database match query'' if the name does not match exactly
one variable name.

\item[get\_all\_table\_stats, gats]() $\rightarrow$ table, retrieves, appends, updates,
deletes, modtime

Retrieves a summary of the table statistics.  Each tuple consists of
the {\em table} name, how many {\em retrieves, appends, updates}, and
{\em deletes} have been performed on that table, and the date of the
last change to the table.  It is safe for this query's ACL to be the
list containing everybody.

\end{description}

\section{Built-in Special Queries}

\begin{description}

\item[\_help](query) $\rightarrow$ help\_message

Returns the short name of the query and a list of arguments and return
values.  The query name must match an existing query.  This query may
be executed by anyone.

\item[\_list\_queries]() $\rightarrow$ long\_query\_name, short\_query\_name

Returns a list of every query name.  This query may be executed by
anyone.

\item[\_list\_users]() $\rightarrow$ kerberos\_principal, host\_address,
port\_number, connect\_time, client\_number

Returns a list of every client currently using the Moira server.  This
query may be executed by anyone.

\item[\_set\_debug\_level, \_sdl](level)

Sets the log\_flags variable in the server to adjust the logging level.
Currently, there are two supported values: 0 and non-0. If the debug
level is non-0, an SQL trace file will be made on the server of all
moirad/DBMS interactions.

\end{description}

\end{document}
