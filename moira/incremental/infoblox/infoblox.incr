#!/moira/bin/python -u

debug = True

import json
import moira
import os
import requests
import struct
import sys
import netaddr
from netaddr import IPAddress
from netaddr import EUI
from subprocess import call
from time import sleep, ctime

# For printing JSON
indent = 2

# IB config
with open('/moira/infoblox/host', 'r') as f:
    ib_host = f.readline().rstrip("\r\n")

ib_user = 'api'

with open('/moira/infoblox/passwd', 'r') as f:
    ib_passwd = f.readline().rstrip("\r\n")

ib_api_version = 'v2.2.2'
ib_base_url = 'https://' + ib_host + '/wapi/' + ib_api_version
ib_common_args = '?_return_type=json-pretty'
ib_search_args = '_return_fields=ipv4addrs,ipv6addrs,name,aliases,use_ttl,ttl,disable,extattrs,view'

default_ttl = 1800
default_domain = "mit.edu"
views = ['internal', 'external']
# Supported types for hostrecord
rr_types = ['MX', 'NS', 'SRV', 'TXT']

# Display an informational message to incr-runner.log.
def log(msg):
    print progname + ': ' + msg

# Write a message to critical.log and send a zephyr message to -c moira.
def critical_log(msg):
    log('critical error: ' + msg)
    timestr = ctime()[4:-5]
    with open('/moira/critical.log', 'a') as f:
        f.write('%s <%d>%s: %s\n' % (timestr, os.getpid(), progname, msg))
    zwrite = '/usr/local/bin/zwrite'
    if os.path.exists(zwrite):
        call([zwrite, '-q', '-d', '-n', '-c', 'moira', '-i', 'incremental', '-m', progname + msg])
    slack = '/moira/bin/slack-send'
    if os.path.exists(slack):
        call(slack, progname + msg)

# Is hostname one we're canonical for?
def canonical_for_hostname(hostname):
    if hostname.lower().endswith(default_domain) and hostname.count('.') == 2:
        return True
    return False

def domoira(query, args):
    try:
        # always connect to localhost 
        moira.connect(os.uname()[1], app=progname)
        moira.mr_version(-1)
        try:
            return moira.mr_query(query, args)
        finally:
            moira.disconnect()
    except moira.error, e:
        # MR_NO_MATCH
        if e[0] == 47836423:
            return []
        else:
            critical_log('could not connect to Moira server: ' + str(e[0]))

def get_moira_hostrecords(hostname):
    return domoira('get_host_resource_record', (hostname, '*'))

def get_moira_hostaliases(hostname):
    return domoira('get_hostalias', ('*', hostname))
                   
def get_moira_hostaddresses(hostname):
    return domoira('get_host_addresses', (hostname, '*'))

def get_moira_host_identifiers(hostname):
    return domoira('get_host_identifier_mapping', (hostname, '*'))

def get_moira_host_status(hostname):
    data, = domoira('get_host', (hostname, '*'))
    return int(data[9])

def get_moira_host(hostname):
    return domoira('get_host', (hostname, '*'))

def mach_to_ib(record):
    extattrs = {
        'moira_mach_id' : { 'value' : record[1] },
        'moira_vendor' : { 'value' : record[2] },
        'moira_model' : { 'value' : record[3] },
        'moira_os' : { 'value' : record[4] },
        'moira_location' : { 'value' : record[5] },
        'moira_contact' : { 'value' : record[6] },
        'moira_billing_contact' : { 'value' : record[7] },
        'moira_account_number' : { 'value' : record[8] },
        'moira_status' : { 'value' : record[9] },
        'moira_owner_type' : { 'value' : record[10] },
        'moira_owner_id' : { 'value' : record[11] },
        'moira_acomment' : { 'value' : record[12] },
        'moira_ocomment' : { 'value' : record[13] },
        }

    if extattrs['moira_owner_id']['value'] == "0":
        extattrs['moira_owner_id']['value'] = "none";

    for key, value in extattrs.items():
        if not value['value']:
            extattrs[key]['value'] = '-'
        else:
            extattrs[key]['value'] = value['value'].lower()

    extattrs['moira_managed'] = { 'value' : 1 }
    
    ib_host_record = {
        'name' : record[0].lower(),
        'extattrs' : extattrs
        }

    return ib_host_record

def ib_search_by_mach_id(mach_id):
    ib_search_url = ib_base_url + '/record:host' + ib_common_args + '&' + ib_search_args
    headers = { 'Content-Type' : 'application/json' }
    payload = { '*moira_mach_id' : mach_id }

    results_by_view = {}
    for view in views:
        results_by_view[view] = []

    data = json.dumps(payload)

    r = requests.get(ib_search_url, data=data, headers=headers, auth=(ib_user, ib_passwd))
    if r.status_code != requests.codes.ok:
        critical_log('Infoblox API call failed in ib_search_by_mach_id for URL %s, payload %s with HTTP status %s, %s' % (ib_search_url, data, r.status_code, r.text))
        return { 'error' : r.text }

    response = r.json()
    for item in response:
        view = item['view']
        results_by_view[view].append(item)

    return results_by_view

def ib_search_by_name(name):
    ib_search_url = ib_base_url + '/record:host' + ib_common_args + '&' + ib_search_args
    headers = { 'Content-Type' : 'application/json' }
    payload = { 'name' : name }

    results_by_view = {}
    for view in views:
        results_by_view[view] = []

    data = json.dumps(payload)

    r = requests.get(ib_search_url, data=data, headers=headers, auth=(ib_user, ib_passwd))
    if r.status_code != requests.codes.ok:
        critical_log('Infoblox API call failed in ib_search_by_name for URL %s, payload %s with HTTP status: %s, %s' % (ib_search_url, data, r.status_code, r.text))
        return { 'error' : r.text }

    response = r.json()
    for item in response:
        view = item['view']
        results_by_view[view].append(item)

    return results_by_view

# Add infoblox host record
def ib_create_host(record, myviews=None):
    # Turn incoming record into something we can work with
    ib_record = mach_to_ib(record)
    moira_mach_id = ib_record['extattrs']['moira_mach_id']['value']
    # Does this record already exist?
    mach_id_results = ib_search_by_mach_id(moira_mach_id)
    name_results = ib_search_by_name(ib_record['name'])

    if 'error' in mach_id_results:
        log('ib_search_by_mach_id returned error, aborting')
        return

    if 'error' in name_results:
        log('ib_search_by_name returned error, aborting')
        return

    # For creation, use dummy v4 IP and default TTL.
    ib_record['ipv4addrs'] = [ { 'ipv4addr' : '0.0.0.0' } ]
    ib_record['ipv6addrs'] = [ ]
    ib_record['ttl'] = default_ttl
    ib_record['use_ttl'] = False
    ib_record['disable'] = True

    if myviews == None:
        myviews = views

    for view in myviews:
        ib_record['view'] = view
        if len(name_results[view]) > 0:
            critical_log("Record already exists for name %s in view %s" % (ib_record['name'], view))
        elif len(mach_id_results[view]) > 0:
            critical_log("Record already exists for mach_id %s in view %s" % (moira_mach_id, view))
        else:
            ib_url = ib_base_url + '/record:host' + ib_common_args
            headers = { 'Content-Type' : 'application/json' }

            r = requests.post(ib_url, data=json.dumps(ib_record), headers=headers, auth=(ib_user, ib_passwd))
            if r.status_code != requests.codes.created:
                critical_log('Infoblox API call failed in ib_create_host for host %s view %s with HTTP status %s, %s' % (ib_record['name'], view, r.status_code, r.text))
                continue

            log('Created host record for %s with mach_id %s in view %s: %s' % (ib_record['name'], moira_mach_id, view, r.text))

# Delete infoblox host record
def ib_delete_host(record):
    ib_record = mach_to_ib(record)
    moira_mach_id = ib_record['extattrs']['moira_mach_id']['value']
    # Does this exist?
    mach_id_results = ib_search_by_mach_id(moira_mach_id)

    if 'error' in mach_id_results:
        log('ib_search_by_mach_id returned error, aborting')
        return

    for view in views:
        ib_record['view'] = view
        if len(mach_id_results[view]) == 0:
            log('No record exists for mach_id %s in view %s, not deleting' % (moira_mach_id, view))
        elif mach_id_results[view][0]['extattrs']['moira_managed']['value'] != 1:
            log('Record for mach_id %s in view %s is not managed by moira, not deleting: moira_managed value is %s' % (moira_mach_id, view, mach_id_results[view][0]['extattrs']['moira_managed']['value']))
        else:
            ib_ref = mach_id_results[view][0]['_ref']
            ib_url = ib_base_url + '/' + ib_ref
            headers = { 'Content-Type' : 'application/json' }

            r = requests.delete(ib_url, headers=headers, auth=(ib_user, ib_passwd))
            if r.status_code != requests.codes.ok:
                critical_log('Infoblox API call failed in ib_delete_host for host %s view %s' % (ib_record['name'], view))
                continue

            log('Deleted host record for %s with mach_id %s in view %s: %s' % (ib_record['name'], moira_mach_id, view, r.text))

# Update host information
def ib_update_host(before, after):
    before_record = mach_to_ib(before)
    after_record = mach_to_ib(after)
    moira_mach_id = before_record['extattrs']['moira_mach_id']['value']

    # This shouldn't ever change.
    if moira_mach_id != after_record['extattrs']['moira_mach_id']['value']:
        critical_log('Moira mach ID changed from %s to %s in an update, this cannot happen!' % (moira_mach_id, after_record['extattrs']['moira_mach_id']['value']))
        return

    mach_id_results = ib_search_by_mach_id(moira_mach_id)
    name_results = ib_search_by_name(after_record['name'])

    if 'error' in mach_id_results:
        log('ib_search_by_mach_id returned error, aborting')
        return

    if 'error' in name_results:
        log('ib_search_by_name returned error, aborting')
        return

    for view in views:
        before_record['view'] = view;
        after_record['view'] = view;

        if len(name_results[view]) > 0 and before_record['name'] != after_record['name']:
            critical_log('Record already exists in view %s for new name %s, old name %s' % (view, before_record['name'], after_record['name']))
        elif len(mach_id_results[view]) == 0:
            log('No record exists for mach id %s in view %s, creating' % (moira_mach_id, view))
            ib_create_host(after, myviews=view)
        elif len(mach_id_results[view]) > 1:
            critical_log('Mutiple records exist for mach_id %s in view %s, should not happen!' % (moira_mach_id, view))
        elif mach_id_results[view][0]['extattrs']['moira_managed']['value'] != 1:
            log('Record for mach_id %s in view %s is not managed by moira, not updating' % (moira_mach_id, view))
        else:
            ib_ref = mach_id_results[view][0]['_ref']
            ib_url = ib_base_url + '/' + ib_ref
            headers = { 'Content-Type' : 'application/json' }

            r = requests.put(ib_url, data=json.dumps(after_record), headers=headers, auth=(ib_user, ib_passwd))
            if r.status_code != requests.codes.ok:
                critical_log('Infoblox API call failed in ib_update_host for host %s view %s' % (after_record['name'], view))
                continue

            log('Updated host record for %s with mach_id %s in view %s: %s' % (after_record['name'], moira_mach_id, view, r.text))

def address_to_ib(record):
    ib_address_record = {
        'name' : record[0].lower(),
        'disable' : False
        }

    addr_type = record[2]
    if addr_type == 'IPV4':
        ib_address_record['ipv4addr'] = record[3]
    elif addr_type == 'IPV6':
        ib_address_record['ipv6addr'] = record[3]
    else:
        critical_log('Unknown IP address type %s in address_to_ib' % (addr_type))
        return

    ttl = int(record[4])
    if ttl == default_ttl:
        ib_address_record['use_ttl'] = False
        ib_address_record['ttl'] = default_ttl
    else:
        ib_address_record['use_ttl'] = True
        ib_address_record['ttl'] = ttl

    return ib_address_record

def ib_search_by_name_and_address(name, addr_type, address):
    if addr_type == 'IPV4':
        object = '/record:a'
        payload = { 'name' : name, 'ipv4addr' : address }
    elif addr_type == 'IPV6':
        object = '/record:aaaa'
        payload = { 'name' : name, 'ipv6addr' : address }
    else:
        error = 'Unknown IP address type %s in ib_search_by_name_and_address' % (addr_type)
        critical_log(error)
        return { 'error' : error }

    ib_search_url = ib_base_url + object + ib_common_args
    headers = { 'Content-Type' : 'application/json' }

    results_by_view = {}
    for view in views:
        results_by_view[view] = []

    data = json.dumps(payload)

    r = requests.get(ib_search_url, data=data, headers=headers, auth=(ib_user, ib_passwd))
    if r.status_code != requests.codes.ok:
        critical_log('Infoblox API call failed in ib_search_by_name_and_address for URL %s, payload %s with HTTP status: %s' % (ib_search_url, data, r.status_code))
        return { 'error' : r.text }

    response = r.json()
    for item in response:
        view = item['view']
        results_by_view[view].append(item)

    return results_by_view

def ib_add_a_record(record):
    ib_record = address_to_ib(record)
    search_results = ib_search_by_name_and_address(ib_record['name'], 'IPV4', ib_record['ipv4addr'])

    if 'error' in search_results:
        log('ib_search_by_name_and_address returned error, aborting')
        return

    for view in views:
        ib_record['view'] = view
        # Never add private address space to external view
        if view == 'external' and IPAddress(ib_record['ipv4addr']).is_private() == True:
            continue
        if len(search_results[view]) > 0:
            critical_log('A record already exists for name %s address %s in view %s' % (ib_record['name'], ib_record['ipv4addr'], view))
        else:
            ib_url = ib_base_url + '/record:a' + ib_common_args
            headers = { 'Content-Type' : 'application/json' }

            r = requests.post(ib_url, data=json.dumps(ib_record), headers=headers, auth=(ib_user, ib_passwd))
            if r.status_code != requests.codes.created:
                critical_log('Infoblox API call failed in ib_add_a_record for name %s address %s view %s' % (ib_record['name'], ib_record['ipv4addr'], view))
                continue

            log('Created A record for name %s address %s in view %s: %s' % (ib_record['name'], ib_record['ipv4addr'], view, r.text))
              
def ib_add_aaaa_record(record):
    ib_record = address_to_ib(record)
    search_results = ib_search_by_name_and_address(ib_record['name'], 'IPV6', ib_record['ipv6addr'])

    if 'error' in search_results:
        log('ib_search_by_name_and_address returned error, aborting')
        return

    for view in views:
        ib_record['view'] = view
        # Never add private address space to external view
        if view == 'external' and IPAddress(ib_record['ipv6addr']).is_private() == True:
            continue
        if len(search_results[view]) > 0:
            critical_log('AAAA record already exists for name %s address %s in view %s' % (ib_record['name'], ib_record['ipv6addr'], view))
        else:
            ib_url = ib_base_url + '/record:aaaa' + ib_common_args
            headers = { 'Content-Type' : 'application/json' }

            r = requests.post(ib_url, data=json.dumps(ib_record), headers=headers, auth=(ib_user, ib_passwd))
            if r.status_code != requests.codes.created:
                critical_log('Infoblox API call failed in ib_add_aaaa_record for name %s address %s view %s' % (ib_record['name'], ib_record['ipv6addr'], view))
                continue

            log('Created AAAA record for name %s address %s in view %s: %s' % (ib_record['name'], ib_record['ipv6addr'], view, r.text))

def alias_to_ib(record):
    ib_alias_record = {
        'name' : record[0].lower(),
        'canonical' : record[1].lower(),
        'disable' : False,
        'ttl' : default_ttl,
        'use_ttl' : False
        }

    return ib_alias_record

def ib_search_by_name_and_cname(name, alias):
    object = '/record:cname'
    ib_search_url = ib_base_url + object + ib_common_args
    headers = { 'Content-Type' : 'application/json' }
    payload = { 'canonical' : name.lower(), 'name' : alias.lower() }

    results_by_view = {}
    for view in views:
        results_by_view[view] = []

    data = json.dumps(payload)
               
    r = requests.get(ib_search_url, data=data, headers=headers, auth=(ib_user, ib_passwd))
    if r.status_code != requests.codes.ok:
        critical_log('Infoblox API call failed in ib_search_by_name_and_cname for URL %s, payload %s with HTTP status %s: %s' % (ib_search_url, data, r.status_code, r.text))
        return { 'error' : r.text }

    response = r.json()
    for item in response:
        view = item['view']
        results_by_view[view].append(item)

    return results_by_view
    
def ib_add_cname(record):
    ib_record = alias_to_ib(record)
    search_results = ib_search_by_name_and_cname(ib_record['canonical'], ib_record['name'])

    if 'error' in search_results:
        log('ib_search_by_name_and_cname returned error, aborting')
        return

    # canonical name should be non-mit.edu if we got here.
    if canonical_for_hostname(ib_record['canonical']) == True:
        critical_log('Request to create explicit CNAME record for %s. alias %s, should not happen!' % (ib_record['canonical'], ib_record['name']))
        return

    for view in views:
        ib_record['view'] = view
        if len(search_results[view]) > 0:
            critical_log('A record already exists for name %s alias %s in view %s' % (ib_record['canonical'], ib_record['name']. view))
        else:
            ib_url = ib_base_url + '/record:cname' + ib_common_args
            headers = { 'Content-Type' : 'application/json' }

            r = requests.post(ib_url, data=json.dumps(ib_record), headers=headers, auth=(ib_user, ib_passwd))
            if r.status_code != requests.codes.created:
                critical_log('Infoblox API call failed in ib_add_cname for name %s alias %s view %s with HTTP status %s: %s' % (ib_record['canonical'], ib_record['name'], view, r.status_code, r.text))
                continue

            log('Created CNAME record for name %s alias %s in view %s: %s' % (ib_record['canonical'], ib_record['name'], view, r.text))
            
def ib_add_host_alias(record):
    ib_record = { 'name' : record[1].lower() }
    alias = record[0].lower()
    search_results = ib_search_by_name(ib_record['name'])

    if 'error' in search_results:
        log('ib_search_by_name returned error, aborting')
        return

    for view in views:
        ib_record['view'] = view
        if len(search_results[view]) == 0:
            critical_log('No host record exists for %s in view %s while adding alias %s, skipping' % (ib_record['name'], view, alias))
        elif len(search_results[view]) > 1:
            critical_log('Multiple host records exist for %s in view %s while adding alias %s, should not happen!' % (ib_record['name'], view, alias))
        else:
            # exactly one result
            search_result = search_results[view][0]
            
            aliases = [ alias ]
            if 'aliases' in search_result:
                for item in search_result['aliases']:
                    aliases.append(item)

            ib_record['aliases'] = aliases

            ib_ref = search_result['_ref']
            ib_url = ib_base_url + '/' + ib_ref
            headers = { 'Content-Type' : 'application/json' }

            r = requests.put(ib_url, data=json.dumps(ib_record), headers=headers, auth=(ib_user, ib_passwd))
            if r.status_code != requests.codes.ok:
                critical_log('Infoblox API call failed in ib_add_host_alias for name %s alias %s view %s with HTTP return %s: %s' % (ib_record['name'], alias, view, r.status_code, r.text))
                continue
    
            log('Added alias %s to host %s in view %s: %s' % (alias, ib_record['name'], view, r.text))

def ib_add_host_identifier(record):
    id_type = record[1]
    if id_type == 'DUID':
        ib_add_host_duid(record)
    elif id_type == 'HWADDR':
        ib_add_host_mac(record)
    else:
        critical_log('Attempted machine identifier add of unknown type %s for host %s' % (id_type, record[0]))

def ib_add_host_duid(record):
    ib_record = { 'name' : record[0].lower() }
    id_type = record[1]
    id_value = record[2]
    search_results = ib_search_by_name(ib_record['name'])

    if 'error' in search_results:
        log('ib_search_by_name returned error, aborting')
        return

    for view in views:
        if view == 'external':
            continue
        ib_record['view'] = view
        if len(search_results[view]) == 0:
            critical_log('No host record exists for %s while adding %s %s in view %s, skipping' % (ib_record['name'], id_type, id_value, view))
        elif len(search_results[view]) > 1:
            critical_log('Multiple host records exist for %s while adding %s %s in view %s, should not happen' % (ib_record['name'], id_type, id_value, view))
        else:
            search_result = search_results[view][0]

            # If we got here, this is guaranteed to exist because of the data model Moira enforces.
            ipv6addrs = [ { 'ipv6addr' : search_result['ipv6addrs'][0]['ipv6addr'] } ]

            ipv6addrs[0]['duid'] = id_value
            ipv6addrs[0]['configure_for_dhcp'] = True

            ib_record['ipv6addrs'] = ipv6addrs

            ib_ref = search_result['_ref']
            ib_url = ib_base_url + '/' + ib_ref
            headers = { 'Content-Type' : 'application/json' }

            r = requests.put(ib_url, data=json.dumps(ib_record), headers=headers, auth=(ib_user, ib_passwd))
            if r.status_code != requests.codes.ok:
                critical_log('Infoblox API call failed in ib_add_host_duid for name %s %s %s in view %s' % (ib_record['name'], id_type, id_value, view))
                continue

            log('Added %s %s to host %s in view %s: %s' % (id_type, id_value, ib_record['name'], view, r.text))

def ib_add_host_mac(record):
    ib_record = { 'name' : record[0].lower() }
    id_type = record[1]
    id_value = str(EUI(record[2], dialect=netaddr.mac_unix_expanded))
    search_results = ib_search_by_name(ib_record['name'])

    if 'error' in search_results:
        log('ib_search_by_name returned error, aborting')
        return

    for view in views:
        if view == 'external':
            continue
        ib_record['view'] = view
        if len(search_results[view]) == 0:
            critical_log('No host record exists for %s while adding %s %s in view %s, skipping' % (ib_record['name'], id_type, id_value, view))
        elif len(search_results[view]) > 1:
            critical_log('Multiple host records exist for %s while adding %s %s in view %s, should not happen' % (ib_record['name'], id_type, id_value, view))
        else:
            search_result = search_results[view][0]
            ipv4addrs = [ { 'ipv4addr' : search_result['ipv4addrs'][0]['ipv4addr'] } ]

            ipv4addrs[0]['mac'] = id_value
            ipv4addrs[0]['configure_for_dhcp'] = True

            ib_record['ipv4addrs'] = ipv4addrs

            ib_ref = search_result['_ref']
            ib_url = ib_base_url + '/' + ib_ref
            headers = { 'Content-Type' : 'application/json' }

            r = requests.put(ib_url, data=json.dumps(ib_record), headers=headers, auth=(ib_user, ib_passwd))
            if r.status_code != requests.codes.ok:
                critical_log('Infoblox API call failed in ib_add_host_mac for name %s %s %s in view %s with HTTP return %s: %s' % (ib_record['name'], id_type, id_value, view, r.status_code, r.text))
                continue

            log('Added %s %s to host %s in view %s: %s' % (id_type, id_value, ib_record['name'], view, r.text))

def ib_add_host_ipv4_address(record):
    ib_record = { 'name' : record[0].lower(), 'disable' : False }

    ttl = int(record[4])
    if ttl == default_ttl:
        ib_record['use_ttl'] = False
        ib_record['ttl'] = default_ttl
    else:
        ib_record['use_ttl'] = True
        ib_record['ttl'] = ttl

    address = record[3]
    search_results = ib_search_by_name(ib_record['name'])

    if 'error' in search_results:
        log('ib_search_by_name returned error, aborting')
        return

    for view in views:
        ib_record['view'] = view
        # No private addresses in external view
        if view == 'external' and IPAddress(address).is_private() == True:
            continue

        if len(search_results[view]) == 0:
            critical_log('No host record exists for %s in view %s while adding IPv4 address %s, skipping' % (ib_record['name'], view, address))
        elif len(search_results[view]) > 1:
            critical_log('Multiple host records exist for %s in view %s while adding IPv4 address %s, should not happen!' % (ib_record['name'], view, address))            
        else:
            # exactly one result, as expected.
            search_result = search_results[view][0]

            ipv4addrs = [ { 'ipv4addr' : address } ]
            # preserve MAC address if assigned.
            if 'ipv4addrs' in search_result and 'mac' in search_result['ipv4addrs'][0]:
                ipv4addrs[0]['mac'] = search_result['ipv4addrs'][0]['mac']
                ipv4addrs[0]['configure_for_dhcp'] = True

            ib_record['ipv4addrs'] = ipv4addrs

            ib_ref = search_result['_ref']
            ib_url = ib_base_url + '/' + ib_ref
            headers = { 'Content-Type' : 'application/json' }

            r = requests.put(ib_url, data=json.dumps(ib_record), headers=headers, auth=(ib_user, ib_passwd))
            if r.status_code != requests.codes.ok:
                critical_log('Infoblox API call failed in ib_add_host_ipv4_address for name %s address %s view %s with HTTP return %s: %s' % (ib_record['name'], address, view, r.status_code, r.text))
                continue

            log('Added IPv4 address %s to host %s in view %s: %s' % (address, ib_record['name'], view, r.text))

def ib_add_host_ipv6_address(record):
    ib_record = { 'name' : record[0].lower(), 'disable' : False }

    ttl = int(record[4])
    if ttl == default_ttl:
        ib_record['use_ttl'] = False
        ib_record['ttl'] = default_ttl
    else:
        ib_record['use_ttl'] = True
        ib_record['ttl'] = ttl

    address = record[3]
    search_results = ib_search_by_name(ib_record['name'])

    if 'error' in search_results:
        log('ib_search_by_name returned error, aborting')
        return

    for view in views:
        ib_record['view'] = view
        # No private addresses in external view
        if view == 'external' and IPAddress(address).is_private() == True:
            continue

        if len(search_results[view]) == 0:
            critical_log('No host record exists for %s in view %s while adding IPv6 address %s, skipping' % (ib_record['name'], view, address))
        elif len(search_results[view]) > 1:
            critical_log('Multiple host records exist for %s in view %s while adding IPv6 address %s, should not happen!' % (ib_record['name'], view, address))
        else:
            # exactly one result, as expected.
            search_result = search_results[view][0]

            ipv6addrs = [ { 'ipv6addr' : address } ]
            # preserve DUID if assigned.
            if 'ipv6addrs' in search_result and 'duid' in search_result['ipv6addrs'][0]:
                ipv6addrs[0]['duid'] = search_result['ipv6addrs'][0]['duid']
                ipv6addrs[0]['configure_for_dhcp'] = True

            ib_record['ipv6addrs'] = ipv6addrs

            # Handle v6 only case; if v4 address is set to 0.0.0.0, set it to empty array.
            if 'ipv4addrs' in search_result and search_result['ipv4addrs'][0]['ipv4addr'] == '0.0.0.0':
                ib_record['ipv4addrs'] = []

            ib_ref = search_result['_ref']
            ib_url = ib_base_url + '/' + ib_ref
            headers = { 'Content-Type' : 'application/json' }

            r = requests.put(ib_url, data=json.dumps(ib_record), headers=headers, auth=(ib_user, ib_passwd))
            if r.status_code != requests.codes.ok:
                critical_log('Infoblox API call failed in ib_add_host_ipv6_address for name %s address %s view %s with HTTP return %s: %s' % (ib_record['name'], address, view, r.status_code, r.text))
                continue

            log('Added IPv6 address %s to host %s in view %s: %s' % (address, ib_record['name'], view, r.text))

def ib_add_hostrecord(record):
    rr_type = record[1]
    if rr_type == 'NS':
        ib_add_delegated_zone(record)
        return
    elif rr_type == 'MX':
        ib_record = mx_to_ib(record)
        if 'error' in ib_record:
            critical_log(ib_record['error'])
            return

        primary_rr_value = ib_record['mail_exchanger']
        object = '/record:mx'

    elif rr_type == 'SRV':
        ib_record = srv_to_ib(record)
        if 'error' in ib_record:
            critical_log(ib_record['error'])
            return
        
        primary_rr_value = ib_record['target']
        object = '/record:srv'

    elif rr_type == 'TXT':
        ib_record = txt_to_ib(record)
        if 'error' in ib_record:
            critical_log(ib_record['error'])
            return

        primary_rr_value = ib_record['text']
        object = '/record:txt'

    else:
        critical_log('Unexpected RR type %s in ib_add_hostrecord' % (rr_type))
        return

    search_results = ib_search_hostrecord(ib_record['name'], rr_type, primary_rr_value)

    if 'error' in search_results:
        log('ib_search_hostrecord returned error, aborting')
        return

    for view in views:
        ib_record['view'] = view
        if len(search_results[view]) > 0:
            critical_log('%s record already exists for name %s value %s in view %s, not adding' % (rr_type, ib_record['name'], primary_rr_value, view))
        else:
            ib_url = ib_base_url + object + ib_common_args
            headers = { 'Content-Type' : 'application/json' }

            r = requests.post(ib_url, data=json.dumps(ib_record), headers=headers, auth=(ib_user, ib_passwd))
            if r.status_code != requests.codes.created:
                critical_log('Infoblox API call failed creating RR type %s for name %s view %s with HTTP return %s: %s' % (rr_type, ib_record['name'], view, r.status_code, r.text))
                continue

            log('Created %s record for name %s value %s in view %s: %s' % (rr_type, ib_record['name'], primary_rr_value, view, r.text))

def ib_search_hostrecord(name, rr_type, value):
    if rr_type == 'MX':
        object = '/record:mx'
        search_key = 'mail_exchanger'
    elif rr_type == 'SRV':
        object = '/record:srv'
        search_key = 'target'
    elif rr_type == 'TXT':
        object = '/record:txt'
        search_key = 'text'

    ib_search_url = ib_base_url + object + ib_common_args
    headers = { 'Content-Type' : 'application/json' }
    payload = { 'name' : name, search_key : value }

    results_by_view = {}
    for view in views:
        results_by_view[view] = []

    data = json.dumps(payload)

    r = requests.get(ib_search_url, data=data, headers=headers, auth=(ib_user, ib_passwd))
    if r.status_code != requests.codes.ok:
        critical_log('Infoblox API call failed in ib_search_hostrecord for RR type %s URL %s payload %s with HTTP status: %s' % (rr_type, ib_search_url, data, r.status_code))
        return { 'error' : r.text }

    response = r.json()
    for item in response:
        view = item['view']
        results_by_view[view] = item

    return results_by_view

def ns_to_ib(record):
    addresses = get_moira_hostaddresses(record[2].upper())
    ib_delegate_to = []
    for address in addresses:
        ib_delegate_element = {
            'name' : address[0].lower(),
            'address' : address[3]
        }

        ib_delegate_to.append(ib_delegate_element)

    ib_ns_record = {
        'fqdn' : record[0].lower(),
        'delegate_to' : ib_delegate_to,
        'disable' : False
    }

    ttl = int(record[3])
    if ttl == default_ttl:
        ib_ns_record['delegated_ttl'] = default_ttl
        ib_ns_record['use_delegated_ttl'] = False
    else:
        ib_ns_record['delegated_ttl'] = ttl
        ib_ns_record['use_delegated_ttl'] = True

    return ib_ns_record

def ib_search_delegated_zone(fqdn):
    ib_search_url = ib_base_url + '/zone_delegated' + ib_common_args
    headers = { 'Content-Type' : 'application/json' }
    payload = { 'fqdn' : fqdn }

    results_by_view = {}
    for view in views:
        results_by_view[view] = []

    data = json.dumps(payload)

    r = requests.get(ib_search_url, data=data, headers=headers, auth=(ib_user, ib_passwd))
    if r.status_code != requests.codes.ok:
        critical_log('Infoblox API call failed in ib_search_delegated_zone for URL %s, payload %s with HTTP status: %s' % (ib_search_url, data, r.status_code))
        return { 'error' : r.text }

    response = r.json()
    for item in response:
        view = item['view']
        results_by_view[view] = item

    return results_by_view

def ib_add_delegated_zone(record):
    ib_record = ns_to_ib(record)
    search_results = ib_search_delegated_zone(ib_record['fqdn'])

    if 'error' in search_results:
        log('ib_search_delegated_zone returned error, aborting')
        return

    for view in views:
        if view == 'external':
            # Make a copy of ib_record['delegated_to'] since we might modify it.
            delegated_to = list(ib_record['delegate_to'])
            # Don't put private addresses in the external zone.
            for item in delegated_to:
                if IPAddress(item['address']).is_private() == True:
                    delegated_to[:] = [ d for d in delegated_to if d.get('address') != item['address']]
            ib_record['delegate_to'] = delegated_to

        ib_record['view'] = view

        if len(search_results[view]) > 0:
            # zone already exists
            for item in search_results[view]['delegate_to']:
                if item not in ib_record['delegate_to']:
                    ib_record['delegate_to'].append(item)

            # Infoblox doesn't allow this for updates, even if it didn't change.
            if 'fqdn' in ib_record:
                del ib_record['fqdn']

            ib_ref = search_results[view]['_ref']
            ib_url = ib_base_url + '/' + ib_ref
            headers = { 'Content-Type' : 'application/json' }

            data = json.dumps(ib_record)
            r = requests.put(ib_url, data=data, headers=headers, auth=(ib_user, ib_passwd))

            if r.status_code != requests.codes.ok:
                critical_log('Infoblox API call failed updating delegated zone %s in view %s with HTTP return %s: %s' % (record[0].lower(), view, r.status_code, r.text))
                continue

            log('Updated delegated zone %s with additional delegation to %s in view %s: %s' % (record[0].lower(), ib_record['delegate_to'][0]['name'], view, r.text))
        else:
            # empty search results, create.
            ib_url = ib_base_url + '/zone_delegated' + ib_common_args
            headers = { 'Content-Type' : 'application/json' }

            data = json.dumps(ib_record)
            r = requests.post(ib_url, data=data, headers=headers, auth=(ib_user, ib_passwd))

            if r.status_code != requests.codes.created:
                critical_log('Infoblox API call failed creating delegated zone %s in view %s with HTTP return %s: %s' % (ib_record['fqdn'], view, r.status_code, r.text))
                continue

            log('Created delegated zone %s with delegation to %s in view %s: %s' % (ib_record['fqdn'], ib_record['delegate_to'][0]['name'], view, r.text))

def txt_to_ib(record):
    ib_txt_record = {
        'name' : record[0].lower(),
        'text' : '"' + record[2].lower() + '"',
        'disable' : False
        }

    ttl = int(record[3])
    if ttl == default_ttl:
        ib_txt_record['ttl'] = default_ttl
        ib_txt_record['use_ttl'] = False
    else:
        ib_txt_record['ttl'] = ttl
        ib_txt_record['use_ttl'] = True

    return ib_txt_record

def srv_to_ib(record):
    ib_srv_record = {
        'name' : record[0].lower(),
        'disable' : False
        }

    if len(record[2].split()) != 4:
        return { 'error' : 'Could not parse SRV record in srv_to_ib' }

    (priority, weight, port, target) = record[2].split()
    if not priority or not weight or not port or not target:
        return { 'error' : 'Could not parse SRV record in srv_to_ib' }
    ib_srv_record['priority'] = int(priority)
    ib_srv_record['weight'] = int(weight)
    ib_srv_record['port'] = int(port)
    ib_srv_record['target'] = target.lower()

    ttl = int(record[3])
    if ttl == default_ttl:
        ib_srv_record['ttl'] = default_ttl
        ib_srv_record['use_ttl'] = False
    else:
        ib_srv_record['ttl'] = ttl
        ib_srv_record['use_ttl'] = True

    return ib_srv_record

def mx_to_ib(record):
    ib_mx_record = {
        'name' : record[0].lower(),
        'disable' : False
        }

    if len(record[2].split()) != 2:
        return { 'error' : 'Could not parse MX record value in mx_to_ib' }

    (weight, mxhost) = record[2].split()
    if not weight or not mxhost:
        return { 'error' : 'Could not parse MX record value in mx_to_ib' }
    ib_mx_record['preference'] = int(weight)
    ib_mx_record['mail_exchanger'] = mxhost.lower()

    ttl = int(record[3])
    if ttl == default_ttl:
        ib_mx_record['ttl'] = default_ttl
        ib_mx_record['use_ttl'] = False
    else:
        ib_mx_record['ttl'] = ttl
        ib_mx_record['use_ttl'] = True
        
    return ib_mx_record

def ib_delete_a_record(record):
    ib_record = address_to_ib(record)
    search_results = ib_search_by_name_and_address(ib_record['name'], 'IPV4', ib_record['ipv4addr'])

    if 'error' in search_results:
        log('ib_search_by_name_and_address returned error, aborting')
        return

    for view in views:
        if len(search_results[view]) == 0:
            log('No A record exists for name %s address %s in view %s, not deleting' % (ib_record['name'], ib_record['ipv4addr'], view))
        else:
            ib_ref = search_results[view][0]['_ref']
            ib_url = ib_base_url + '/' + ib_ref
            headers = { 'Content-Type' : 'application/json' }

            r = requests.delete(ib_url, headers=headers, auth=(ib_user, ib_passwd))
            if r.status_code != requests.codes.ok:
                critical_log('Infoblox API call failed in ib_delete_a_record for name %s address %s view %s' % (ib_record['name'], ib_record['ipv4addr'], view))
                continue

            log('Deleted A record for name %s address %s in view %s: %s' % (ib_record['name'], ib_record['ipv4addr'], view, r.text))

def ib_delete_aaaa_record(record):
    ib_record = address_to_ib(record)
    search_results = ib_search_by_name_and_address(ib_record['name'], 'IPV6', ib_record['ipv6addr'])

    if 'error' in search_results:
        log('ib_search_by_name_and_address returned error, aborting')
        return

    for view in views:
        if len(search_results[view]) == 0:
            log('No AAAA record exists for name %s address %s in view %s, not deleting' % (ib_record['name'], ib_record['ipv6addr'], view))
        else:
            ib_ref = search_results[view][0]['_ref']
            ib_url = ib_base_url + '/' + ib_ref
            headers = { 'Content-Type' : 'application/json' }

            r = requests.delete(ib_url, headers=headers, auth=(ib_user, ib_passwd))
            if r.status_code != requests.codes.ok:
                critical_log('Infoblox API call failed in ib_delete_aaaa_record for name %s address %s view %s' % (ib_record['name'], ib_record['ipv6addr'], view))
                continue

            log('Deleted AAAA record for name %s address %s in view %s: %s' % (ib_record['name'], ib_record['ipv6addr'], view, r.text))

def ib_delete_cname(record):
    ib_record = alias_to_ib(record)
    search_results = ib_search_by_name_and_cname(ib_record['canonical'], ib_record['name'])

    if 'error' in search_results:
        log('ib_search_by_name_and_cname returned error, aborting')
        return

    for view in views:
        if len(search_results[view]) == 0:
            log('No CNAME record exists for name %s alias %s in view %s, not deleting' % (ib_record['canonical'], ib_record['name'], view))
        else:
            ib_ref = search_results[view][0]['_ref']
            ib_url = ib_base_url + '/' + ib_ref
            headers = { 'Content-Type' : 'application/json' }

            r = requests.delete(ib_url, headers=headers, auth=(ib_user, ib_passwd))
            if r.status_code != requests.codes.ok:
                critical_log('Infoblox API call failed in ib_delete_cname for name %s alias %s view %s' % (ib_record['canonical'], ib_record['name'], view))
                continue
                
            log('Deleted CNAME record for name %s alias %s in view %s: %s' % (ib_record['canonical'], ib_record['name'], view, r.text))

def ib_delete_host_alias(record):
    ib_record = { 'name' : record[1].lower() }
    alias = record[0].lower()
    search_results = ib_search_by_name(ib_record['name'])

    if 'error' in search_results:
        log('ib_search_by_name returned error, aborting')
        return

    for view in views:
        ib_record['view'] = view
        if len(search_results[view]) == 0:
            log('No host record exists for %s in view %s while deleting alias %s, skipping' % (ib_record['name'], view, alias))
        elif len(search_results[view]) > 1:
            critical_log('Multiple host records exist for %s in view %s while deleting alias %s, should not happen!' % (ib_record['name'], view, alias))
        else:
            search_result = search_results[view][0]
            
            aliases = [ x for x in search_result['aliases'] if x != alias]
            ib_record['aliases'] = aliases

            ib_ref = search_result['_ref']
            ib_url = ib_base_url + '/' + ib_ref
            headers = { 'Content-Type' : 'application/json' }

            r = requests.put(ib_url, data=json.dumps(ib_record), headers=headers, auth=(ib_user, ib_passwd))
            if r.status_code != requests.codes.ok:
                critical_log('Infoblox API call failed in ib_delete_host_alias for name %s alias %s view %s with HTTP return %s: %s' % (ib_record['name'], alias, view, r.status_code, r.text))
                continue

            log('Deleted alias %s from host %s in view %s: %s' % (alias, ib_record['name'], view, r.text))

def ib_delete_host_identifier(record):
    id_type = record[1]
    if id_type == 'DUID':
        ib_delete_host_duid(record)
    elif id_type == 'HWADDR':
        ib_delete_host_mac(record)
    else:
        critical_log('Attempted machine identifier delete of unknown type %s for host %s' % (id_type, record[0]))

def ib_delete_host_duid(record):
    ib_record = { 'name' : record[0].lower() }
    id_type = record[1]
    # Infoblox formats these things like MAC addresses, but longer, for some reason.
    id_value = ':'.join(s.encode('hex') for s in record[2].decode('hex'))
    search_results = ib_search_by_name(ib_record['name'])

    if 'error' in search_results:
        log('ib_search_by_name returned error, aborting')
        return

    for view in views:
        if view == 'external':
            continue
        ib_record['view'] = view
        if len(search_results[view]) == 0:
            log('No host record exists for %s while deleting %s %s in view %s, skipping' % (ib_record['name'], id_type, id_value, view))
        elif len(search_results[view]) > 1:
            critical_log('Multiple host records exist for %s in view %s while deleting %s %s, should not happen!' % (ib_record['name'], view, id_type, id_value))
        else:
            search_result = search_results[view][0]
            ipv6addrs = [ { 'ipv6addr' : search_result['ipv6addrs'][0]['ipv6addr'] } ]

            if 'duid' in search_result['ipv6addrs'][0]:
                if search_result['ipv6addrs'][0]['duid'] == id_value:
                    ipv6addrs[0]['duid'] = ''
                    ipv6addrs[0]['configure_for_dhcp'] = False
                else:
                    critical_log('DUID %s does not match attempted delete of %s for host %s in view %s, not deleting' % (search_result['ipv6addrs'][0]['duid'], id_value, ib_record['name'], view))
                    continue

            ib_record['ipv6addrs'] = ipv6addrs

            ib_ref = search_result['_ref']
            ib_url = ib_base_url + '/' + ib_ref
            headers = { 'Content-Type' : 'application/json' }

            r = requests.put(ib_url, data=json.dumps(ib_record), headers=headers, auth=(ib_user, ib_passwd))
            if r.status_code != requests.codes.ok:
                critical_log('Infoblox API call failed in ib_delete_host_duid for name %s %s %s view %s with HTTP return %s: %s' % (ib_record['name'], id_type, id_value, view, r.status_code, r.text))
                continue

            log('Deleted %s %s for host %s in view %s: %s' % (id_type, id_value, ib_record['name'], view, r.text))

def ib_delete_host_mac(record):
    ib_record = { 'name' : record[0].lower() }
    id_type = record[1]
    id_value = str(EUI(record[2], dialect=netaddr.mac_unix_expanded))
    search_results = ib_search_by_name(ib_record['name'])

    if 'error' in search_results:
        log('ib_search_by_name returned error, aborting')
        return

    for view in views:
        if view == 'external':
            continue
        ib_record['view'] = view
        if len(search_results[view]) == 0:
            log('No host record exists for %s while deleting %s %s in view %s, skipping' % (ib_record['name'], id_type, id_value, view))
        elif len(search_results[view]) > 1:
            critical_log('Multiple host records exist for %s in view %s while deleting %s %s, should not happen!' % (ib_record['name'],  view, id_type, id_value))
        else:
            # exactly one result
            search_result = search_results[view][0]
            ipv4addrs = [ { 'ipv4addr' : search_result['ipv4addrs'][0]['ipv4addr'] } ]

            if 'mac' in search_result['ipv4addrs'][0]:
                if search_result['ipv4addrs'][0]['mac'] == id_value:
                    ipv4addrs[0]['mac'] = ''
                    ipv4addrs[0]['configure_for_dhcp'] = False
                else:
                    critical_log('MAC address %s does not match attempted delete of %s for host %s in view %s, not deleting' % (search_result['ipv4addrs'][0]['mac'], id_value, ib_record['name'], view))
                    continue

            ib_record['ipv4addrs'] = ipv4addrs

            ib_ref = search_result['_ref']
            ib_url = ib_base_url + '/' + ib_ref
            headers = { 'Content-Type' : 'application/json' }

            r = requests.put(ib_url, data=json.dumps(ib_record), headers=headers, auth=(ib_user, ib_passwd))
            if r.status_code != requests.codes.ok:
                critical_log('Infoblox API call failed in ib_delete_host_mac for name %s %s %s view %s with HTTP return %s: %s' % (ib_record['name'], id_type, id_value, view, r.status_code, r.text))
                continue

            log('Deleted %s %s for host %s in view %s: %s' % (id_type, id_value, ib_record['name'], view, r.text))

def ib_delete_host_ipv4_address(record):
    ib_record = { 'name' : record[0].lower() }
    address = record[3]
    search_results = ib_search_by_name(ib_record['name'])

    if 'error' in search_results:
        log('ib_search_by_name returned error, aborting')
        return
    
    for view in views:
        ib_record['view'] = view
        if len(search_results[view]) == 0:
            log('No host record exists for %s in view %s while deleting IPv4 address %s, skipping' % (ib_record['name'], view, address))
        elif len(search_results[view]) > 1:
            critical_log('Multiple host records exist for %s in view %s while deleting IPv4 address %s, should not happen!' % (ib_record['name'], view, address))
        else:
            # exactly one result, as expected.
            search_result = search_results[view][0]

            # Do we still have a v6 address assigned?
            if 'ipv6addrs' in search_result and search_result['ipv6addrs'][0]['ipv6addr'] != '::':
                ipv4addrs = []
            else:
                ipv4addrs = [ { 'ipv4addr' : '0.0.0.0' } ]
                # preserve MAC address if assigned.
                if 'mac' in search_result['ipv4addrs'][0]:
                    ipv4addrs[0]['mac'] = search_result['ipv4addrs'][0]['mac']
                    ipv4addrs[0]['configure_for_dhcp'] = True
                    ib_record['disable'] = True

            ib_record['ipv4addrs'] = ipv4addrs

            ib_ref = search_result['_ref']
            ib_url = ib_base_url + '/' + ib_ref
            headers = { 'Content-Type' : 'application/json' }

            r = requests.put(ib_url, data=json.dumps(ib_record), headers=headers, auth=(ib_user, ib_passwd))
            if r.status_code != requests.codes.ok:
                critical_log('Infoblox API call failed in ib_delete_host_ipv4_address for name %s address %s view %s with HTTP return %s: %s' % (ib_record['name'], address, view, r.status_code, r.text))
                continue

            log('Deleted IPv4 address %s for host %s in view %s: %s' % (address, ib_record['name'], view, r.text))

def ib_delete_host_ipv6_address(record):
    ib_record = { 'name' : record[0].lower() }
    address = record[3]
    search_results = ib_search_by_name(ib_record['name'])

    if 'error' in search_results:
        log('ib_search_by_name returned error, aborting')
        return

    for view in views:
        ib_record['view'] = view
        if len(search_results[view]) == 0:
            log('No host record exists for %s in view %s while deleting IPv6 address %s, skipping' % (ib_record['name'], view, address))
        elif len(search_results[view]) > 1:
            critical_log('Multiple host records exist for %s in view %s while deleting IPv6 address %s, should not happen!' % (ib_record['name'], view, address))
        else:
            # exactly one result, as expected.
            search_result = search_results[view][0]

            ipv6addrs = [ ]
            # preserve DUID if assigned.
            if 'ipv6addrs' in search_result and 'duid' in search_result['ipv6addrs'][0]:
                ipv6addrs[0] = {}
                ipv6addrs[0]['duid'] = search_result['ipv6addrs'][0]['duid']
                ipv6addrs[0]['configure_for_dhcp'] = True
                          
            ib_record['ipv6addrs'] = ipv6addrs

            # Do we still have a valid v4 address?
            if 'ipv4addrs' not in search_result:
                ib_record['ipv4addrs'] = [ { 'ipv4addr' : '0.0.0.0' } ]
                ib_record['disable'] = True
            elif 'ipv4addrs' in search_result and search_result['ipv4addrs'][0]['ipv4addr'] == '0.0.0.0':
                ib_record['disable'] = True

            ib_ref = search_result['_ref']
            ib_url = ib_base_url + '/' + ib_ref
            headers = { 'Content-Type' : 'application/json' }

            r = requests.put(ib_url, data=json.dumps(ib_record), headers=headers, auth=(ib_user, ib_passwd))
            if r.status_code != requests.codes.ok:
                critical_log('Infoblox API call failed in ib_delete_host_ipv6_address for name %s address %s view %s with HTTP return %s: %s' % (ib_record['name'], address, view, r.status_code, r.text))
                continue

            log('Deleted IPv6 address %s for host %s in view %s: %s' % (address, ib_record['name'], view, r.text))

def ib_delete_hostrecord(record):
    rr_type = record[1]
    if rr_type == 'NS':
        ib_delete_delegated_zone(record)
        return
    elif rr_type == 'MX':
        ib_record = mx_to_ib(record)
        if 'error' in ib_record:
            critical_log(ib_record['error'])
            return
        primary_rr_value = ib_record['mail_exchanger']
    elif rr_type == 'SRV':
        ib_record = srv_to_ib(record)
        if 'error' in ib_record:
            critical_log(ib_record['error'])
            return
        primary_rr_value = ib_record['target']
    elif rr_type == 'TXT':
        ib_record = txt_to_ib(record)
        if 'error' in ib_record:
            critical_log(ib_record['error'])
        primary_rr_value = ib_record['text']
    else:
        critical_log('Unexpected RR type %s in ib_delete_hostrecord' % (rr_type))
        return

    search_results = ib_search_hostrecord(ib_record['name'], rr_type, primary_rr_value)

    if 'error' in search_results:
        log('ib_search_hostrecord returned error, aborting')
        return

    for view in views:
        if len(search_results[view]) == 0:
            if rr_type == 'TXT':
                # search is stupid
                search_results = ib_search_hostrecord(ib_record['name'], rr_type, primary_rr_value.strip('"'))
        
        if len(search_results[view]) == 0:
            log('No %s record exists for name %s value %s in view %s, not deleting' % (rr_type, ib_record['name'], primary_rr_value, view))
        else:
            ib_ref = search_results[view]['_ref']
            ib_url = ib_base_url + '/' + ib_ref
            headers = { 'Content-Type' : 'application/json' }

            r = requests.delete(ib_url, headers=headers, auth=(ib_user, ib_passwd))
            if r.status_code != requests.codes.ok:
                critical_log('Infoblox API call failed in ib_delete_hostrecord for RR type %s name %s view %s with HTTP return %s: %s' % (rr_type, ib_record['name'], view, r.status_code, r.text))
                continue

            log('Deleted %s record for name %s value %s in view %s: %s' % (rr_type, ib_record['name'], primary_rr_value, view, r.text))

def ib_delete_delegated_zone(record):
    ib_record = ns_to_ib(record)
    search_results = ib_search_delegated_zone(ib_record['fqdn'])

    if 'error' in search_results:
        log('ib_search_delegated_zone returned error, aborting')
        return

    deleted_delegation = list(ib_record['delegate_to'])

    for view in views:
        if len(search_results[view]) == 0:
            log('No delegated zone record for %s exists in view %s, not deleting' % (ib_record['fqdn'], view))
        else:
            ib_ref = search_results[view]['_ref']
            ib_url = ib_base_url + '/' + ib_ref
            headers = { 'Content-Type' : 'application/json' }
            new_delegated_to = [ x for x in search_results[view]['delegate_to'] if x not in deleted_delegation ]

            if len(new_delegated_to) == 0:
                r = requests.delete(ib_url, headers=headers, auth=(ib_user, ib_passwd))
                if r.status_code != requests.codes.ok:
                    critical_log('Infoblox API call failed for DELETE in ib_delete_delegated_zone of zone %s view %s with HTTP return %s: %s' % (record[0].lower(), view, r.status_code, r.text))
                    continue
                log('Deleted delegated zone %s in view %s: %s' % (record[0].lower(), view, r.text))

                # Infoblox nuked our host record when we did this, but Moira might still expect it to exist.  Check and put it back if so.
                # This case should only come up in a 'real' incremental, where we have the mach_id.
                if len(record) == 5:
                    name_results = ib_search_by_name(record[0].lower())

                    if 'error' in name_results:
                        log('ib_search_by_mach_id returned error, aborting')
                        return

                    if len(name_results[view]) > 0:
                        # host record still exists for some reason, which is weird.
                        critical_log('Infoblox host record for %s in view %s still exists after delegated zone deletion, should not happen!' % (record[0].lower(), view))
                        return
                    else:
                        # No record exists, make one.
                        hostinfo, = get_moira_host(record[0])
                        # Reshuffle output of get_host into incremental argv, inserting mach_id.
                        create_record = [ hostinfo[0], record[4], hostinfo[1], hostinfo[2], hostinfo[3], hostinfo[4], hostinfo[5], hostinfo[6], hostinfo[7],
                                          hostinfo[9], hostinfo[11], hostinfo[12], hostinfo[13], hostinfo[14] ]
                        # Since we're already in our view loop, only do this for the current view
                        ib_create_host(create_record, myviews=[view])
            else:
                # Infoblox doesn't allow this for updates, even if it hasn't changed.
                if 'fqdn' in ib_record:
                    del ib_record['fqdn']
                
                ib_record['delegate_to'] = new_delegated_to
                r = requests.put(ib_url, data=json.dumps(ib_record), headers=headers, auth=(ib_user, ib_passwd))
                if r.status_code != requests.codes.ok:
                    critical_log('Infoblox API call failed for PUT in ib_delete_delegated_zone of zone %s view %s with HTTP return %s: %s' % (record[0].lower(), view, r.status_code, r.text))
                    continue

                log('Updated delegated zone %s to remove delegation to %s in view %s: %s' % (record[0].lower(), record[2], view, r.text))
        
def ib_set_aaaa_record_ttl(record):
    ib_record = address_to_ib(record)
    search_results = ib_search_by_name_and_address(ib_record['name'], 'IPV6', ib_record['ipv6addr'])

    if 'error' in search_results:
        log('ib_search_by_name_and_address returned error, aborting')
        return

    for view in views:
        if len(search_results[view]) == 0:
            critical_log('No AAAA record exists for name %s address %s in view %s while updating TTL' % (ib_record['name'], ib_record['ipv6addr'], view))
        elif len(search_results[view]) > 1:
            critical_log('Multiple AAAA records exist for name %s address %s in view %s, should not happen' % (ib_record['name'], ib_record['ipv6addr'], view))
        else:
            ib_ref = search_results[view][0]['_ref']
            ib_url = ib_base_url + '/' + ib_ref
            headers = { 'Content-Type' : 'application/json' }

            r = requests.put(ib_url, data=json.dumps(ib_record), headers=headers, auth=(ib_user, ib_passwd))
            if r.status_code != requests.codes.ok:
                critical_log('Infoblox API call failed in ib_set_aaaa_record_ttl for name %s address %s view %s with HTTP return %s: %s' % (ib_record['name'], ib_record['ipv6addr'], view, r.status_code, r.text))
                continue

            log('Updated TTL for AAAA record %s address %s in view %s to %s' % (ib_record['name'], ib_record['ipv6addr'], view, ib_record['ttl']))

def ib_set_a_record_ttl(record):
    ib_record = address_to_ib(record)
    search_results = ib_search_by_name_and_address(ib_record['name'], 'IPV4', ib_record['ipv4addr'])

    if 'error' in search_results:
        log('ib_search_by_name_and_address returned error, aborting')
        return

    for view in views:
        if len(search_results[view]) == 0:
            critical_log('No A record exists for name %s address %s in view %s while updating TTL' % (ib_record['name'], ib_record['ipv4addr'], view))
        elif len(search_results[view]) > 1:
            critical_log('Multiple A records exist for name %s address %s in view %s, should not happen' % (ib_record['name'], ib_record['ipv4addr'], view))
        else:
            ib_ref = search_results[view][0]['_ref']
            ib_url = ib_base_url + '/' + ib_ref
            headers = { 'Content-Type' : 'application/json' }

            r = requests.put(ib_url, data=json.dumps(ib_record), headers=headers, auth=(ib_user, ib_passwd))
            if r.status_code != requests.codes.ok:
                critical_log('Infoblox API call failed in ib_set_a_record_ttl for name %s address %s view %s with HTTP return %s: %s' % (ib_record['name'], ib_record['ipv4addr'], view, r.status_code, r.text))
                continue

            log('Updated TTL for A record %s address %s in view %s to %s' % (ib_record['name'], ib_record['ipv4addr'], view, ib_record['ttl']))

def ib_set_host_ttl(record):
    hostname = record[0].lower()
    ttl = int(record[4])
    ib_record = { 'name': hostname, 'ttl' : ttl, 'use_ttl' : True }
    search_results = ib_search_by_name(hostname)

    if 'error' in search_results:
        log('ib_search_by_name returned error, aborting')
        return

    for view in views:
        ib_record['view'] = view
        if len(search_results[view]) == 0:
            critical_log('No host record exists for %s in view %s while setting TTL' % (ib_record['name'], view))
        elif len(search_results[view]) > 1:
            critical_log('Multiple host records exist for %s in view %s, should not happen' % (ib_record['name'], view))
        else:
            ib_ref = search_results[view][0]['_ref']
            ib_url = ib_base_url + '/' + ib_ref
            headers = { 'Content-Type' : 'application/json' }

            r = requests.put(ib_url, data=json.dumps(ib_record), headers=headers, auth=(ib_user, ib_passwd))
            if r.status_code != requests.codes.ok:
                critical_log('Infoblox API call failed in ib_set_host_ttl for host %s view %s' % (ib_record['name'], view))
                continue

            log('Updated TTL for host record %s in view %s to %s' % (ib_record['name'], view, ib_record['ttl']))

def ib_set_record_ttl(record):
    rr_type = record[1]
    if rr_type == 'NS':
        ib_set_delegated_zone_ttl(record)
        return
    elif rr_type == 'MX':
        ib_record = mx_to_ib(record)
        primary_rr_value = ib_record['mail_exchanger']
    elif rr_type == 'SRV':
        ib_record = srv_to_ib(record)
        primary_rr_value = ib_record['target']
    elif rr_type == 'TXT':
        ib_record = txt_to_ib(record)
        primary_rr_value = ib_record['text']
    else:
        critical_log('Unexpected RR type %s in ib_set_record_ttl' % (rr_type))
        return

    search_results = ib_search_hostrecord(ib_record['name'], rr_type, primary_rr_value)

    if 'error' in search_results:
        log('ib_search_hostrecord returned error, aborting')
        return

    for view in views:
        ib_record['view'] = view
        if len(search_results[view]) == 0:
            critical_log('No %s record exists for name %s value %s in view %s while setting TTL' % (rr_type, ib_record['name'], primary_rr_value, view))
        else:
            ib_ref = search_results[view]['_ref']
            ib_url = ib_base_url + '/' + ib_ref
            headers = { 'Content-Type' : 'application/json' }

            r = requests.put(ib_url, data=json.dumps(ib_record), headers=headers, auth=(ib_user, ib_passwd))
            if r.status_code != requests.codes.ok:
                critical_log('Infoblox API call failed in ib_set_record_ttl for type %s name %s view %s with HTTP return %s: %s' % (rr_type, ib_record['name'], view, r.status_code, r.text))
                continue

            log('Updated TTL for %s record %s value %s in view %s to %s' % (rr_type, ib_record['name'], primary_rr_value, view, ib_record['ttl']))

def ib_set_delegated_zone_ttl(record):
    zonename = record[0].lower()
    ttl = int(record[3])

    ib_record = { 'fqdn' : zonename, 'disable' : False }
    if ttl == default_ttl:
        ib_record['delegated_ttl'] = default_ttl
        ib_record['use_delegated_ttl'] = False
    else:
        ib_record['delegated_ttl'] = ttl
        ib_record['use_delegated_ttl'] = True

    search_results = ib_search_delegated_zone(zonename)

    if 'error' in search_results:
        log('ib_search_delegated_zone returned error, aborting')
        return

    for view in views:
        ib_record['view'] = view
        if len(search_results[view]) == 0:
            critical_log('No delegated zone record for %s exists in view %s while setting TTL' % (zonename, view))
        else:
            ib_ref = search_results[view]['_ref']
            ib_url = ib_base_url + '/' + ib_ref
            headers = { 'Content-Type' : 'application/json' }

            # Infoblox doesn't allow this for updates, even if it hasn't changed.
            if 'fqdn' in ib_record:
                del ib_record['fqdn']

            r = requests.put(ib_url, data=json.dumps(ib_record), headers=headers, auth=(ib_user, ib_passwd))

            if r.status_code != requests.codes.ok:
                critical_log('Infoblox API call failed setting TTL for delegated zone %s view %s with HTTP return %s: %s' % (zonename, view, r.status_code, r.text))
                continue

            log('Updated TTL for delegated zone %s in view %s to %s' % (zonename, view, ttl))

# Handle machine incremental
def do_machine(before, after):
    # Add
    if before == []:
        after_status = int(after[9])
        hostname = after[0]
        if after_status == 1 and canonical_for_hostname(hostname):
            ib_create_host(after)
    # Delete
    elif after == []:
        # Must be status 3 to be deleted and already handled via update path.
        log('nothing to do for deleted host %s' % (before[0]))
    # Update
    else:
        before_status = int(before[9])
        after_status = int(after[9])

        if after_status != 1:

            # Delete DNS records that may be associated with before name.
            hostname = before[0]
            for record in get_moira_hostrecords(hostname):
                ib_delete_hostrecord(record)

            # Check for cross-domain CNAME.
            if canonical_for_hostname(hostname) == False:
                for record in get_moira_hostaliases(hostname):
                    ib_delete_cname(record)

            # Get host addresses and delete.
            for record in get_moira_hostaddresses(hostname):
                has_ptr = int(record[5])
                addr_type = record[2]
                if has_ptr == 0:
                    if addr_type == 'IPV4':
                        ib_delete_a_record(record)
                    elif addr_type == 'IPV6':
                        ib_delete_aaaa_record(record)

            # Lastly, delete host record
            ib_delete_host(before)
                
        elif after_status == 1:
            if before_status != 1:
                hostname = after[0]
                canon = canonical_for_hostname(hostname)

                # Are we canonical for this name?  If so, handle everything
                # If not, only handle CNAME records.
                if canon == True:
                    # primary host record
                    ib_create_host(after)
                    
                    # aliases
                    for record in get_moira_hostaliases(hostname):
                        ib_add_host_alias(record)
                        
                    # host addresses
                    for record in get_moira_hostaddresses(hostname):
                        has_ptr = int(record[5])
                        addr_type = record[2]
                        if has_ptr == 1:
                            if addr_type == 'IPV4':
                                ib_add_host_ipv4_address(record)
                            elif addr_type == 'IPV6':
                                ib_add_host_ipv6_address(record)
                        else:
                            if addr_type == 'IPV4':
                                ib_add_a_record(record)
                            elif addr_type == 'IPV6':
                                ib_add_aaaa_record(record)

                    # host records
                    for record in get_moira_hostrecords(hostname):
                        ib_add_hostrecord(record)

                    # mach identifiers
                    for record in get_moira_host_identifiers(hostname):
                        ib_add_host_identifier(record)
                else:
                    for record in get_moira_hostaliases(hostname):
                        ib_add_cname(record)

            else:
                # active before and after
                before_hostname = before[0]
                after_hostname = after[0]

                canon_before = canonical_for_hostname(before_hostname)
                canon_after = canonical_for_hostname(after_hostname)

                # If hostname changed, need to handle other bits of information
                if before_hostname != after_hostname:

                    # If we're no longer canonical, delete the host object.
                    if canon_before == True and canon_after == True:
                        ib_update_host(before, after)
                    elif canon_before == False and canon_after == True:
                        ib_create_host(after)
                    elif canon_after == False:
                        ib_delete_host(before)
                               
                    # Host records
                    for record in get_moira_hostrecords(after_hostname):
                        if canon_after == True:
                            ib_add_hostrecord(record)
                        if canon_before == True:
                            recordlist = list(record)
                            recordlist[0] = before_hostname
                            ib_delete_hostrecord(recordlist)

                    # CNAMEs.  Aliases directly associated with the host record
                    # will have moved as part of ib_update_host()
                    for record in get_moira_hostaliases(after_hostname):
                        if canon_before == True and canon_after == False:
                            ib_add_cname(record)
                        elif canon_before == False and canon_after == True:
                            recordlist = list(record)
                            recordlist[1] = before_hostname
                            ib_delete_cname(recordlist)
                            ib_add_host_alias(record)
                        elif canon_before == False and canon_after == False:
                            ib_add_cname(record)
                            recordlist = list(record)
                            recordlist[1] = before_hostname
                            ib_delete_cname(recordlist)

                    # Host addreses        
                    for record in get_moira_hostaddresses(after_hostname):
                        has_ptr = int(record[5])
                        addr_type = record[2]
                        if canon_after == True:
                            # Addresses directly associated with host record will have moved
                            # as part of ib_update_host()
                            if has_ptr == 0:
                                if addr_type == 'IPV4':
                                    ib_add_a_record(record)
                                elif addr_type == 'IPV6':
                                    ib_add_aaaa_record(record)
                        if canon_before == True:
                            recordlist = list(record)
                            recordlist[0] = before_hostname
                            if has_ptr == 0:
                                if addr_type == 'IPV4':
                                    ib_delete_a_record(recordlist)
                                elif addr_type == 'IPV6':
                                    ib_delete_aaaa_record(recordlist)
                else:
                    ib_update_host(before, after)

# Handle hostalias incremental
def do_hostalias(before, after):
    # Add
    if before == []:
        hostname = after[1]
        status = int(get_moira_host_status(hostname))
        if status == 1:
            if canonical_for_hostname(hostname) == True:
                ib_add_host_alias(after)
            else:
                ib_add_cname(after)
    # Delete
    elif after == []:
        hostname = before[1]
        if canonical_for_hostname(hostname) == True:
            ib_delete_host_alias(before)
        else:
            ib_delete_cname(before)
    # update case with both before and after not empty can't happen

# Handle hostaddress incremental
def do_hostaddress(before, after):
    # Add
    if before == []:
        hostname = after[0]
        has_ptr = int(after[5])
        addr_type = after[2]
        status = int(get_moira_host_status(hostname))
        if status == 1 and canonical_for_hostname(hostname) == True:
            if has_ptr == 1:
                if addr_type == 'IPV4':
                    ib_add_host_ipv4_address(after)
                elif addr_type == 'IPV6':
                    ib_add_host_ipv6_address(after)
            else:
                status = int(get_moira_host_status(hostname))
                if status == 1:
                    if addr_type == 'IPV4':
                        ib_add_a_record(after)
                    elif addr_type == 'IPV6':
                        ib_add_aaaa_record(after)
    # Delete
    elif after == []:
        hostname = before[0]
        has_ptr = int(before[5])
        addr_type = before[2]
        if canonical_for_hostname(hostname) == True:
            if has_ptr == 1:
                if addr_type == 'IPV4':
                    ib_delete_host_ipv4_address(before)
                elif addr_type == 'IPV6':
                    ib_delete_host_ipv6_address(before)
            else:
                status = int(get_moira_host_status(hostname))
                if status == 1:
                    if addr_type == 'IPV4':
                        ib_delete_a_record(before)
                    elif addr_type == 'IPV6':
                        ib_delete_aaaa_record(before)
    # Update - TTL, PTR, or address might change, but only one at a time.
    else:
        hostname = after[0]
        before_ptr = int(before[5])
        after_ptr = int(after[5])
        addr_type = after[2]
        before_address = before[3]
        after_address = after[3]

        status = int(get_moira_host_status(hostname))

        if before_address != after_address:
            # This can only change if we're upgrading a host to a public address.
            # Otherwise it would be a delete and an add.
            if status == 1:
                ib_delete_host_ipv4_address(before)
                ib_add_host_ipv4_address(after)
        elif before_ptr != after_ptr:
            # ptr bit changed.
            if status == 1:
                if before_ptr == 0 and after_ptr == 1:
                    if addr_type == 'IPV4':
                        ib_delete_a_record(before)
                        ib_add_host_ipv4_address(after)
                    elif addr_type == 'IPV6':
                        ib_delete_aaaa_record(before)
                        ib_add_host_ipv6_address(after)
                elif before_ptr == 1 and after_ptr == 0:
                    if addr_type == 'IPV4':
                        ib_delete_host_ipv4_address(before)
                        ib_add_a_record(after)
                    elif addr_type == 'IPV6':
                        ib_delete_host_ipv6_address(before)
                        ib_add_aaaa_record(after)
        else:
            # if here, ttl must have changed.
            if status == 1:
                if after_ptr == 1:
                    ib_set_host_ttl(after)
                else:
                    if addr_type == 'IPV4':
                        ib_set_a_record_ttl(after)
                    elif addr_type == 'IPV6':
                        ib_set_aaaa_record_ttl(after)

# Handle hostrecord incremental
def do_hostrecord(before, after):
    # Add
    if before == []:
        hostname = after[0]
        rr_type = after[1]
        status = int(get_moira_host_status(hostname))
        if status == 1 and canonical_for_hostname(hostname) == True:
            if rr_type in rr_types:
                ib_add_hostrecord(after)
            else:
                log('received incremental for unsupported DNS RR type %s' % (rr_type))
    # Delete
    elif after == []:
        hostname = before[0]
        rr_type = before[1]
        if canonical_for_hostname(hostname) == True:
            if rr_type in rr_types:
                ib_delete_hostrecord(before)
            else:
                log('received incremental for unsupported DNS RR type %s' % (rr_type))
    # Update - only thing that can change is TTL
    else:
        hostname = after[0]
        rr_type = after[1]
        status = int(get_moira_host_status(hostname))
        if status == 1 and canonical_for_hostname(hostname) == True:
            if rr_type in rr_types:
                ib_set_record_ttl(after)
            else:
                log('received incremental for unsupported DNS RR type %s' % (rr_type))

# Handle machidentifier incremental
def do_machidentifier(before, after):
    # Add
    if before == []:
        hostname = after[0]
        id_type = after[1]
        if canonical_for_hostname(hostname) == True:
            ib_add_host_identifier(after)
    # Delete
    elif after == []:
        hostname = before[0]
        id_type = before[1]
        if canonical_for_hostname(hostname) == True:
            ib_delete_host_identifier(before)
    # update case with before and after not empty can't happen
        
progname = os.path.basename(sys.argv[0])
print progname + ' pipe child starting'
sys.stdout.flush()
# main loop
while True:
    # Pause for up to 30 minutes while the stop file exists.
    stop_file = '/moira/infoblox/noinfoblox'
    stop_check_count = 0
    while os.path.exists(stop_file):
        sleep(60)
        if stop_check_count > 30:
            critical_log('incremental failed (%s exists)' % stop_file)
            sys.exit(1)
        stop_check_count +=1

    # read length of incremental argv
    lenbytes = sys.stdin.read(4)
    if len(lenbytes) == 0:
        print progname + ' pipe child exiting'
        break
    l, = struct.unpack('>L', lenbytes)
    # read and parse incremental argv
    incrargv = sys.stdin.read(l).split('\0')
    table = incrargv[0]
    beforec = int(incrargv[1])
    afterc = int(incrargv[2])
    beforev = incrargv[3:3+beforec]
    afterv = incrargv[3+beforec:3+beforec+afterc]

    if table == 'machine':
        do_machine(beforev, afterv)
    elif table == 'hostalias':
        do_hostalias(beforev, afterv)
    elif table == 'hostaddress':
        do_hostaddress(beforev, afterv)
    elif table == 'hostrecord':
        do_hostrecord(beforev, afterv)
    elif table == 'machidentifiermap':
        do_machidentifier(beforev, afterv)
    else:
        error = 'Incremental received on unexpected table %s' % table
        critical_log(error)
        
exit(0)
